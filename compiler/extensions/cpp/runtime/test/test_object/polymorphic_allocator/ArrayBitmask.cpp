/**
 * Automatically generated by Zserio C++ generator version 1.1.0 using Zserio core 2.15.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, typeInfoCode, reflectionCode, parsingInfoCode, polymorphicAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/TypeInfo.h>
#include <zserio/pmr/AnyHolder.h>
#include <zserio/pmr/Reflectable.h>

#include <test_object/polymorphic_allocator/ArrayBitmask.h>

namespace test_object
{
namespace polymorphic_allocator
{

ArrayBitmask::ArrayBitmask(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

ArrayBitmask::ArrayBitmask(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

const ::zserio::pmr::ITypeInfo& ArrayBitmask::typeInfo()
{
    using allocator_type = ::zserio::pmr::PropagatingPolymorphicAllocator<>;

    static const ::zserio::Span<::zserio::StringView> underlyingTypeArguments;

    static const ::std::array<::zserio::ItemInfo, 3> values = {
        ::zserio::ItemInfo{ ::zserio::makeStringView("CREATE"), static_cast<uint64_t>(UINT8_C(1)), false, false},
        ::zserio::ItemInfo{ ::zserio::makeStringView("READ"), static_cast<uint64_t>(UINT8_C(2)), false, false},
        ::zserio::ItemInfo{ ::zserio::makeStringView("WRITE"), static_cast<uint64_t>(UINT8_C(4)), false, false}
    };

    static const ::zserio::BitmaskTypeInfo<allocator_type> typeInfo = {
        ::zserio::makeStringView("test_object.polymorphic_allocator.ArrayBitmask"),
        ::zserio::BuiltinTypeInfo<allocator_type>::getUInt8(), underlyingTypeArguments, values
    };

    return typeInfo;
}

::zserio::pmr::IReflectablePtr ArrayBitmask::reflectable(const ::zserio::pmr::PropagatingPolymorphicAllocator<>& allocator) const
{
    class Reflectable : public ::zserio::ReflectableBase<::zserio::pmr::PropagatingPolymorphicAllocator<>>
    {
    public:
        explicit Reflectable(::test_object::polymorphic_allocator::ArrayBitmask bitmask) :
                ::zserio::ReflectableBase<::zserio::pmr::PropagatingPolymorphicAllocator<>>(::test_object::polymorphic_allocator::ArrayBitmask::typeInfo()),
                m_bitmask(bitmask)
        {}

        size_t bitSizeOf(size_t bitPosition) const override
        {
            return m_bitmask.bitSizeOf(bitPosition);
        }

        void write(::zserio::BitStreamWriter& writer) const override
        {
            m_bitmask.write(writer);
        }

        ::zserio::pmr::AnyHolder getAnyValue(const ::zserio::pmr::PropagatingPolymorphicAllocator<>& alloc) const override
        {
            return ::zserio::pmr::AnyHolder(m_bitmask, alloc);
        }

        ::zserio::pmr::AnyHolder getAnyValue(const ::zserio::pmr::PropagatingPolymorphicAllocator<>& alloc) override
        {
            return ::zserio::pmr::AnyHolder(m_bitmask, alloc);
        }

        uint8_t getUInt8() const override
        {
            return m_bitmask.getValue();
        }

        uint64_t toUInt() const override
        {
            return m_bitmask.getValue();
        }

        double toDouble() const override
        {
            return static_cast<double>(toUInt());
        }

        ::zserio::pmr::string toString(const ::zserio::pmr::PropagatingPolymorphicAllocator<>& alloc) const override
        {
            return m_bitmask.toString(alloc);
        }

    private:
        ::test_object::polymorphic_allocator::ArrayBitmask m_bitmask;
    };

    return ::std::allocate_shared<Reflectable>(allocator, *this);
}

void ArrayBitmask::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::StdIntArrayTraits<::test_object::polymorphic_allocator::ArrayBitmask::underlying_type>>(m_value);
}

size_t ArrayBitmask::bitSizeOf(size_t) const
{
    return UINT8_C(8);
}

size_t ArrayBitmask::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<::test_object::polymorphic_allocator::ArrayBitmask::underlying_type>>(m_value);
}

size_t ArrayBitmask::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t ArrayBitmask::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t ArrayBitmask::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void ArrayBitmask::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value, UINT8_C(8));
}

void ArrayBitmask::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::StdIntArrayTraits<::test_object::polymorphic_allocator::ArrayBitmask::underlying_type>>(out, m_value);
}

::zserio::pmr::string ArrayBitmask::toString(const ::zserio::pmr::string::allocator_type& allocator) const
{
    ::zserio::pmr::string result(allocator);
    if ((*this & ArrayBitmask::Values::CREATE) == ArrayBitmask::Values::CREATE)
    {
        result += result.empty() ? "CREATE" : " | CREATE";
    }
    if ((*this & ArrayBitmask::Values::READ) == ArrayBitmask::Values::READ)
    {
        result += result.empty() ? "READ" : " | READ";
    }
    if ((*this & ArrayBitmask::Values::WRITE) == ArrayBitmask::Values::WRITE)
    {
        result += result.empty() ? "WRITE" : " | WRITE";
    }

    return ::zserio::toString<::zserio::pmr::string::allocator_type>(m_value, allocator) + "[" + result + "]";
}

ArrayBitmask::underlying_type ArrayBitmask::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readBits(UINT8_C(8)));
}

ArrayBitmask::underlying_type ArrayBitmask::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::StdIntArrayTraits<::test_object::polymorphic_allocator::ArrayBitmask::underlying_type>>(
            in);
}

} // namespace polymorphic_allocator
} // namespace test_object
