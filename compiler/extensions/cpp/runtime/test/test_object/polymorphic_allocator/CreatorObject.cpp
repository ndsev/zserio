/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, typeInfoCode, reflectionCode, polymorphicAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/TypeInfo.h>
#include <zserio/pmr/AnyHolder.h>
#include <zserio/pmr/Reflectable.h>

#include <test_object/polymorphic_allocator/CreatorObject.h>

namespace test_object
{
namespace polymorphic_allocator
{

CreatorObject::CreatorObject(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_value_(uint32_t()),
        m_nested_(allocator),
        m_text_(allocator),
        m_nestedArray_(allocator),
        m_textArray_(allocator),
        m_externArray_(::zserio::NullOpt),
        m_bytesArray_(::zserio::NullOpt),
        m_optionalBool_(::zserio::NullOpt),
        m_optionalNested_(::zserio::NullOpt)
{
}

CreatorObject::CreatorObject(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_value_(readValue(in)),
        m_nested_(readNested(in, allocator)),
        m_text_(readText(in, allocator)),
        m_nestedArray_(readNestedArray(in, allocator)),
        m_textArray_(readTextArray(in, allocator)),
        m_externArray_(readExternArray(in, allocator)),
        m_bytesArray_(readBytesArray(in, allocator)),
        m_optionalBool_(readOptionalBool(in)),
        m_optionalNested_(readOptionalNested(in, allocator))
{
}

CreatorObject::CreatorObject(CreatorObject::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_value_(readValue(context, in)),
        m_nested_(readNested(context, in, allocator)),
        m_text_(readText(in, allocator)),
        m_nestedArray_(readNestedArray(context, in, allocator)),
        m_textArray_(readTextArray(in, allocator)),
        m_externArray_(readExternArray(in, allocator)),
        m_bytesArray_(readBytesArray(in, allocator)),
        m_optionalBool_(readOptionalBool(in)),
        m_optionalNested_(readOptionalNested(context, in, allocator))
{
}

CreatorObject::CreatorObject(const CreatorObject& other) :
        m_value_(other.m_value_),
        m_nested_(other.m_nested_),
        m_text_(other.m_text_),
        m_nestedArray_(other.m_nestedArray_),
        m_textArray_(other.m_textArray_),
        m_externArray_(other.m_externArray_),
        m_bytesArray_(other.m_bytesArray_),
        m_optionalBool_(other.m_optionalBool_),
        m_optionalNested_(other.m_optionalNested_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

CreatorObject& CreatorObject::operator=(const CreatorObject& other)
{
    m_value_ = other.m_value_;
    m_nested_ = other.m_nested_;
    m_text_ = other.m_text_;
    m_nestedArray_ = other.m_nestedArray_;
    m_textArray_ = other.m_textArray_;
    m_externArray_ = other.m_externArray_;
    m_bytesArray_ = other.m_bytesArray_;
    m_optionalBool_ = other.m_optionalBool_;
    m_optionalNested_ = other.m_optionalNested_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

CreatorObject::CreatorObject(CreatorObject&& other) :
        m_value_(::std::move(other.m_value_)),
        m_nested_(::std::move(other.m_nested_)),
        m_text_(::std::move(other.m_text_)),
        m_nestedArray_(::std::move(other.m_nestedArray_)),
        m_textArray_(::std::move(other.m_textArray_)),
        m_externArray_(::std::move(other.m_externArray_)),
        m_bytesArray_(::std::move(other.m_bytesArray_)),
        m_optionalBool_(::std::move(other.m_optionalBool_)),
        m_optionalNested_(::std::move(other.m_optionalNested_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

CreatorObject& CreatorObject::operator=(CreatorObject&& other)
{
    m_value_ = ::std::move(other.m_value_);
    m_nested_ = ::std::move(other.m_nested_);
    m_text_ = ::std::move(other.m_text_);
    m_nestedArray_ = ::std::move(other.m_nestedArray_);
    m_textArray_ = ::std::move(other.m_textArray_);
    m_externArray_ = ::std::move(other.m_externArray_);
    m_bytesArray_ = ::std::move(other.m_bytesArray_);
    m_optionalBool_ = ::std::move(other.m_optionalBool_);
    m_optionalNested_ = ::std::move(other.m_optionalNested_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

CreatorObject::CreatorObject(::zserio::PropagateAllocatorT,
        const CreatorObject& other, const allocator_type& allocator) :
        m_value_(::zserio::allocatorPropagatingCopy(other.m_value_, allocator)),
        m_nested_(::zserio::allocatorPropagatingCopy(other.m_nested_, allocator)),
        m_text_(::zserio::allocatorPropagatingCopy(other.m_text_, allocator)),
        m_nestedArray_(::zserio::allocatorPropagatingCopy(other.m_nestedArray_, allocator)),
        m_textArray_(::zserio::allocatorPropagatingCopy(other.m_textArray_, allocator)),
        m_externArray_(::zserio::allocatorPropagatingCopy(other.m_externArray_, allocator)),
        m_bytesArray_(::zserio::allocatorPropagatingCopy(other.m_bytesArray_, allocator)),
        m_optionalBool_(::zserio::allocatorPropagatingCopy(other.m_optionalBool_, allocator)),
        m_optionalNested_(::zserio::allocatorPropagatingCopy(other.m_optionalNested_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

const ::zserio::pmr::ITypeInfo& CreatorObject::typeInfo()
{
    static const ::zserio::StringView templateName;
    static const ::zserio::Span<::zserio::BasicTemplateArgumentInfo<allocator_type>> templateArguments;

    static const ::std::array<::zserio::StringView, 1> nestedTypeArguments = {
        ::zserio::makeStringView("getValue()")
    };
    static const ::std::array<::zserio::StringView, 1> nestedArrayTypeArguments = {
        ::zserio::makeStringView("getValue()")
    };
    static const ::std::array<::zserio::StringView, 1> optionalNestedTypeArguments = {
        ::zserio::makeStringView("getValue()")
    };
    static const ::std::array<::zserio::BasicFieldInfo<allocator_type>, 9> fields = {
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("value"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getUInt32(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("nested"), // schemaName
            ::test_object::polymorphic_allocator::CreatorNested::typeInfo(), // typeInfo
            nestedTypeArguments, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("text"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getString(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("nestedArray"), // schemaName
            ::test_object::polymorphic_allocator::CreatorNested::typeInfo(), // typeInfo
            nestedArrayTypeArguments, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            true, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("textArray"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getString(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            true, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("externArray"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getBitBuffer(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            true, // isOptional
            {}, // optionalClause
            {}, // constraint
            true, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("bytesArray"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getBytes(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            true, // isOptional
            {}, // optionalClause
            {}, // constraint
            true, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("optionalBool"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getBool(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            true, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("optionalNested"), // schemaName
            ::test_object::polymorphic_allocator::CreatorNested::typeInfo(), // typeInfo
            optionalNestedTypeArguments, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            true, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        }
    };

    static const ::zserio::Span<::zserio::BasicParameterInfo<allocator_type>> parameters;

    static const ::zserio::Span<::zserio::BasicFunctionInfo<allocator_type>> functions;

    static const ::zserio::StructTypeInfo<allocator_type> typeInfo = {
        ::zserio::makeStringView("test_object.polymorphic_allocator.CreatorObject"),
        [](const allocator_type& allocator) -> ::zserio::pmr::IReflectablePtr
        {
            return std::allocate_shared<::zserio::ReflectableOwner<CreatorObject>>(allocator, allocator);
        },
        templateName, templateArguments,
        fields, parameters, functions
    };

    return typeInfo;
}

::zserio::pmr::IReflectableConstPtr CreatorObject::reflectable(const allocator_type& allocator) const
{
    class Reflectable : public ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>
    {
    public:
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::getField;
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::getParameter;
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::callFunction;
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::getAnyValue;

        explicit Reflectable(const ::test_object::polymorphic_allocator::CreatorObject& object, const allocator_type& allocator) :
                ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>(::test_object::polymorphic_allocator::CreatorObject::typeInfo(), allocator),
                m_object(object)
        {}

        size_t bitSizeOf(size_t bitPosition) const override
        {
            return m_object.bitSizeOf(bitPosition);
        }

        void write(::zserio::BitStreamWriter& writer) const override
        {
            m_object.write(writer);
        }

        ::zserio::pmr::IReflectableConstPtr getField(::zserio::StringView name) const override
        {
            if (name == ::zserio::makeStringView("value"))
            {
                return ::zserio::pmr::ReflectableFactory::getUInt32(m_object.getValue(), get_allocator());
            }
            if (name == ::zserio::makeStringView("nested"))
            {
                return m_object.getNested().reflectable(get_allocator());
            }
            if (name == ::zserio::makeStringView("text"))
            {
                return ::zserio::pmr::ReflectableFactory::getString(m_object.getText(), get_allocator());
            }
            if (name == ::zserio::makeStringView("nestedArray"))
            {
                return ::zserio::pmr::ReflectableFactory::getCompoundArray(m_object.getNestedArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("textArray"))
            {
                return ::zserio::pmr::ReflectableFactory::getStringArray(m_object.getTextArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("externArray"))
            {
                if (!m_object.isExternArraySet())
                    return nullptr;

                return ::zserio::pmr::ReflectableFactory::getBitBufferArray(m_object.getExternArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("bytesArray"))
            {
                if (!m_object.isBytesArraySet())
                    return nullptr;

                return ::zserio::pmr::ReflectableFactory::getBytesArray(m_object.getBytesArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalBool"))
            {
                if (!m_object.isOptionalBoolSet())
                    return nullptr;

                return ::zserio::pmr::ReflectableFactory::getBool(m_object.getOptionalBool(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalNested"))
            {
                if (!m_object.isOptionalNestedSet())
                    return nullptr;

                return m_object.getOptionalNested().reflectable(get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'CreatorObject'!";
        }

        ::zserio::pmr::AnyHolder getAnyValue(const allocator_type& allocator) const override
        {
            return ::zserio::pmr::AnyHolder(::std::cref(m_object), allocator);
        }

    private:
        const ::test_object::polymorphic_allocator::CreatorObject& m_object;
    };

    return std::allocate_shared<Reflectable>(allocator, *this, allocator);
}

::zserio::pmr::IReflectablePtr CreatorObject::reflectable(const allocator_type& allocator)
{
    class Reflectable : public ::zserio::ReflectableAllocatorHolderBase<allocator_type>
    {
    public:
        explicit Reflectable(::test_object::polymorphic_allocator::CreatorObject& object, const allocator_type& allocator) :
                ::zserio::ReflectableAllocatorHolderBase<allocator_type>(::test_object::polymorphic_allocator::CreatorObject::typeInfo(), allocator),
                m_object(object)
        {}

        void initializeChildren() override
        {
            m_object.initializeChildren();
        }

        size_t initializeOffsets(size_t bitPosition) override
        {
            return m_object.initializeOffsets(bitPosition);
        }

        size_t bitSizeOf(size_t bitPosition) const override
        {
            return m_object.bitSizeOf(bitPosition);
        }

        void write(::zserio::BitStreamWriter& writer) const override
        {
            m_object.write(writer);
        }

        ::zserio::pmr::IReflectableConstPtr getField(::zserio::StringView name) const override
        {
            if (name == ::zserio::makeStringView("value"))
            {
                return ::zserio::pmr::ReflectableFactory::getUInt32(m_object.getValue(), get_allocator());
            }
            if (name == ::zserio::makeStringView("nested"))
            {
                return m_object.getNested().reflectable(get_allocator());
            }
            if (name == ::zserio::makeStringView("text"))
            {
                return ::zserio::pmr::ReflectableFactory::getString(m_object.getText(), get_allocator());
            }
            if (name == ::zserio::makeStringView("nestedArray"))
            {
                return ::zserio::pmr::ReflectableFactory::getCompoundArray(m_object.getNestedArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("textArray"))
            {
                return ::zserio::pmr::ReflectableFactory::getStringArray(m_object.getTextArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("externArray"))
            {
                if (!m_object.isExternArraySet())
                    return nullptr;

                return ::zserio::pmr::ReflectableFactory::getBitBufferArray(m_object.getExternArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("bytesArray"))
            {
                if (!m_object.isBytesArraySet())
                    return nullptr;

                return ::zserio::pmr::ReflectableFactory::getBytesArray(m_object.getBytesArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalBool"))
            {
                if (!m_object.isOptionalBoolSet())
                    return nullptr;

                return ::zserio::pmr::ReflectableFactory::getBool(m_object.getOptionalBool(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalNested"))
            {
                if (!m_object.isOptionalNestedSet())
                    return nullptr;

                return m_object.getOptionalNested().reflectable(get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'CreatorObject'!";
        }

        ::zserio::pmr::IReflectablePtr getField(::zserio::StringView name) override
        {
            if (name == ::zserio::makeStringView("value"))
            {
                return ::zserio::pmr::ReflectableFactory::getUInt32(m_object.getValue(), get_allocator());
            }
            if (name == ::zserio::makeStringView("nested"))
            {
                return m_object.getNested().reflectable(get_allocator());
            }
            if (name == ::zserio::makeStringView("text"))
            {
                return ::zserio::pmr::ReflectableFactory::getString(m_object.getText(), get_allocator());
            }
            if (name == ::zserio::makeStringView("nestedArray"))
            {
                return ::zserio::pmr::ReflectableFactory::getCompoundArray(m_object.getNestedArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("textArray"))
            {
                return ::zserio::pmr::ReflectableFactory::getStringArray(m_object.getTextArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("externArray"))
            {
                if (!m_object.isExternArraySet())
                    return nullptr;

                return ::zserio::pmr::ReflectableFactory::getBitBufferArray(m_object.getExternArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("bytesArray"))
            {
                if (!m_object.isBytesArraySet())
                    return nullptr;

                return ::zserio::pmr::ReflectableFactory::getBytesArray(m_object.getBytesArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalBool"))
            {
                if (!m_object.isOptionalBoolSet())
                    return nullptr;

                return ::zserio::pmr::ReflectableFactory::getBool(m_object.getOptionalBool(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalNested"))
            {
                if (!m_object.isOptionalNestedSet())
                    return nullptr;

                return m_object.getOptionalNested().reflectable(get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'CreatorObject'!";
        }

        void setField(::zserio::StringView name,
                const ::zserio::AnyHolder<allocator_type>& value) override
        {
            if (name == ::zserio::makeStringView("value"))
            {
                m_object.setValue(value.get<uint32_t>());
                return;
            }
            if (name == ::zserio::makeStringView("nested"))
            {
                m_object.setNested(value.get<::test_object::polymorphic_allocator::CreatorNested>());
                return;
            }
            if (name == ::zserio::makeStringView("text"))
            {
                m_object.setText(value.get<::zserio::pmr::string>());
                return;
            }
            if (name == ::zserio::makeStringView("nestedArray"))
            {
                m_object.setNestedArray(value.get<::zserio::pmr::vector<::test_object::polymorphic_allocator::CreatorNested>>());
                return;
            }
            if (name == ::zserio::makeStringView("textArray"))
            {
                m_object.setTextArray(value.get<::zserio::pmr::vector<::zserio::pmr::string>>());
                return;
            }
            if (name == ::zserio::makeStringView("externArray"))
            {
                if (value.isType<::std::nullptr_t>())
                {
                    m_object.resetExternArray();
                    return;
                }

                m_object.setExternArray(value.get<::zserio::pmr::vector<::zserio::pmr::BitBuffer>>());
                return;
            }
            if (name == ::zserio::makeStringView("bytesArray"))
            {
                if (value.isType<::std::nullptr_t>())
                {
                    m_object.resetBytesArray();
                    return;
                }

                m_object.setBytesArray(value.get<::zserio::pmr::vector<::zserio::pmr::vector<uint8_t>>>());
                return;
            }
            if (name == ::zserio::makeStringView("optionalBool"))
            {
                if (value.isType<::std::nullptr_t>())
                {
                    m_object.resetOptionalBool();
                    return;
                }

                m_object.setOptionalBool(value.get<bool>());
                return;
            }
            if (name == ::zserio::makeStringView("optionalNested"))
            {
                if (value.isType<::std::nullptr_t>())
                {
                    m_object.resetOptionalNested();
                    return;
                }

                m_object.setOptionalNested(value.get<::test_object::polymorphic_allocator::CreatorNested>());
                return;
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'CreatorObject'!";
        }

        ::zserio::pmr::IReflectablePtr createField(::zserio::StringView name) override
        {
            if (name == ::zserio::makeStringView("value"))
            {
                m_object.setValue(uint32_t());
                return ::zserio::pmr::ReflectableFactory::getUInt32(m_object.getValue(), get_allocator());
            }
            if (name == ::zserio::makeStringView("nested"))
            {
                m_object.setNested(::test_object::polymorphic_allocator::CreatorNested(get_allocator()));
                return m_object.getNested().reflectable(get_allocator());
            }
            if (name == ::zserio::makeStringView("text"))
            {
                m_object.setText(::zserio::pmr::string(get_allocator()));
                return ::zserio::pmr::ReflectableFactory::getString(m_object.getText(), get_allocator());
            }
            if (name == ::zserio::makeStringView("nestedArray"))
            {
                m_object.setNestedArray(::zserio::pmr::vector<::test_object::polymorphic_allocator::CreatorNested>(get_allocator()));
                return ::zserio::pmr::ReflectableFactory::getCompoundArray(m_object.getNestedArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("textArray"))
            {
                m_object.setTextArray(::zserio::pmr::vector<::zserio::pmr::string>(get_allocator()));
                return ::zserio::pmr::ReflectableFactory::getStringArray(m_object.getTextArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("externArray"))
            {
                m_object.setExternArray(::zserio::pmr::vector<::zserio::pmr::BitBuffer>(get_allocator()));
                return ::zserio::pmr::ReflectableFactory::getBitBufferArray(m_object.getExternArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("bytesArray"))
            {
                m_object.setBytesArray(::zserio::pmr::vector<::zserio::pmr::vector<uint8_t>>(get_allocator()));
                return ::zserio::pmr::ReflectableFactory::getBytesArray(m_object.getBytesArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalBool"))
            {
                m_object.setOptionalBool(bool());
                return ::zserio::pmr::ReflectableFactory::getBool(m_object.getOptionalBool(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalNested"))
            {
                m_object.setOptionalNested(::test_object::polymorphic_allocator::CreatorNested(get_allocator()));
                return m_object.getOptionalNested().reflectable(get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'CreatorObject'!";
        }

        ::zserio::pmr::AnyHolder getAnyValue(const allocator_type& allocator) const override
        {
            return ::zserio::pmr::AnyHolder(::std::cref(m_object), allocator);
        }

        ::zserio::pmr::AnyHolder getAnyValue(const allocator_type& allocator) override
        {
            return ::zserio::pmr::AnyHolder(::std::ref(m_object), allocator);
        }

    private:
        ::test_object::polymorphic_allocator::CreatorObject& m_object;
    };

    return std::allocate_shared<Reflectable>(allocator, *this, allocator);
}

void CreatorObject::initializeChildren()
{
    m_nested_.initialize(static_cast<uint32_t>(getValue()));
    m_nestedArray_.initializeElements(*this);
    if (isOptionalNestedSet())
        m_optionalNested_.value().initialize(static_cast<uint32_t>(getValue()));

    m_areChildrenInitialized = true;
}

uint32_t CreatorObject::getValue() const
{
    return m_value_;
}

void CreatorObject::setValue(uint32_t value_)
{
    m_value_ = value_;
}

::test_object::polymorphic_allocator::CreatorNested& CreatorObject::getNested()
{
    return m_nested_;
}

const ::test_object::polymorphic_allocator::CreatorNested& CreatorObject::getNested() const
{
    return m_nested_;
}

void CreatorObject::setNested(const ::test_object::polymorphic_allocator::CreatorNested& nested_)
{
    m_nested_ = nested_;
}

void CreatorObject::setNested(::test_object::polymorphic_allocator::CreatorNested&& nested_)
{
    m_nested_ = ::std::move(nested_);
}

::zserio::pmr::string& CreatorObject::getText()
{
    return m_text_;
}

const ::zserio::pmr::string& CreatorObject::getText() const
{
    return m_text_;
}

void CreatorObject::setText(const ::zserio::pmr::string& text_)
{
    m_text_ = text_;
}

void CreatorObject::setText(::zserio::pmr::string&& text_)
{
    m_text_ = ::std::move(text_);
}

::zserio::pmr::vector<::test_object::polymorphic_allocator::CreatorNested>& CreatorObject::getNestedArray()
{
    return m_nestedArray_.getRawArray();
}

const ::zserio::pmr::vector<::test_object::polymorphic_allocator::CreatorNested>& CreatorObject::getNestedArray() const
{
    return m_nestedArray_.getRawArray();
}

void CreatorObject::setNestedArray(const ::zserio::pmr::vector<::test_object::polymorphic_allocator::CreatorNested>& nestedArray_)
{
    m_nestedArray_ = ZserioArrayType_nestedArray(nestedArray_);
}

void CreatorObject::setNestedArray(::zserio::pmr::vector<::test_object::polymorphic_allocator::CreatorNested>&& nestedArray_)
{
    m_nestedArray_ = ZserioArrayType_nestedArray(std::move(nestedArray_));
}

::zserio::pmr::vector<::zserio::pmr::string>& CreatorObject::getTextArray()
{
    return m_textArray_.getRawArray();
}

const ::zserio::pmr::vector<::zserio::pmr::string>& CreatorObject::getTextArray() const
{
    return m_textArray_.getRawArray();
}

void CreatorObject::setTextArray(const ::zserio::pmr::vector<::zserio::pmr::string>& textArray_)
{
    m_textArray_ = ZserioArrayType_textArray(textArray_);
}

void CreatorObject::setTextArray(::zserio::pmr::vector<::zserio::pmr::string>&& textArray_)
{
    m_textArray_ = ZserioArrayType_textArray(std::move(textArray_));
}

::zserio::pmr::vector<::zserio::pmr::BitBuffer>& CreatorObject::getExternArray()
{
    return m_externArray_.value().getRawArray();
}

const ::zserio::pmr::vector<::zserio::pmr::BitBuffer>& CreatorObject::getExternArray() const
{
    return m_externArray_.value().getRawArray();
}

void CreatorObject::setExternArray(const ::zserio::pmr::vector<::zserio::pmr::BitBuffer>& externArray_)
{
    m_externArray_ = ZserioArrayType_externArray(externArray_);
}

void CreatorObject::setExternArray(::zserio::pmr::vector<::zserio::pmr::BitBuffer>&& externArray_)
{
    m_externArray_ = ZserioArrayType_externArray(std::move(externArray_));
}

bool CreatorObject::isExternArrayUsed() const
{
    return (isExternArraySet());
}

bool CreatorObject::isExternArraySet() const
{
    return m_externArray_.hasValue();
}

void CreatorObject::resetExternArray()
{
    m_externArray_.reset();
}

::zserio::pmr::vector<::zserio::pmr::vector<uint8_t>>& CreatorObject::getBytesArray()
{
    return m_bytesArray_.value().getRawArray();
}

const ::zserio::pmr::vector<::zserio::pmr::vector<uint8_t>>& CreatorObject::getBytesArray() const
{
    return m_bytesArray_.value().getRawArray();
}

void CreatorObject::setBytesArray(const ::zserio::pmr::vector<::zserio::pmr::vector<uint8_t>>& bytesArray_)
{
    m_bytesArray_ = ZserioArrayType_bytesArray(bytesArray_);
}

void CreatorObject::setBytesArray(::zserio::pmr::vector<::zserio::pmr::vector<uint8_t>>&& bytesArray_)
{
    m_bytesArray_ = ZserioArrayType_bytesArray(std::move(bytesArray_));
}

bool CreatorObject::isBytesArrayUsed() const
{
    return (isBytesArraySet());
}

bool CreatorObject::isBytesArraySet() const
{
    return m_bytesArray_.hasValue();
}

void CreatorObject::resetBytesArray()
{
    m_bytesArray_.reset();
}

bool CreatorObject::getOptionalBool() const
{
    return m_optionalBool_.value();
}

void CreatorObject::setOptionalBool(bool optionalBool_)
{
    m_optionalBool_ = optionalBool_;
}

bool CreatorObject::isOptionalBoolUsed() const
{
    return (isOptionalBoolSet());
}

bool CreatorObject::isOptionalBoolSet() const
{
    return m_optionalBool_.hasValue();
}

void CreatorObject::resetOptionalBool()
{
    m_optionalBool_.reset();
}

::test_object::polymorphic_allocator::CreatorNested& CreatorObject::getOptionalNested()
{
    return m_optionalNested_.value();
}

const ::test_object::polymorphic_allocator::CreatorNested& CreatorObject::getOptionalNested() const
{
    return m_optionalNested_.value();
}

void CreatorObject::setOptionalNested(const ::test_object::polymorphic_allocator::CreatorNested& optionalNested_)
{
    m_optionalNested_ = optionalNested_;
}

void CreatorObject::setOptionalNested(::test_object::polymorphic_allocator::CreatorNested&& optionalNested_)
{
    m_optionalNested_ = ::std::move(optionalNested_);
}

bool CreatorObject::isOptionalNestedUsed() const
{
    return (isOptionalNestedSet());
}

bool CreatorObject::isOptionalNestedSet() const
{
    return m_optionalNested_.hasValue();
}

void CreatorObject::resetOptionalNested()
{
    m_optionalNested_.reset();
}

void CreatorObject::initPackingContext(CreatorObject::ZserioPackingContext& context) const
{
    context.getValue().init<::zserio::StdIntArrayTraits<uint32_t>>(m_value_);
    m_nested_.initPackingContext(context.getNested());
    if (isOptionalNestedSet())
    {
        m_optionalNested_.value().initPackingContext(context.getOptionalNested());
    }
}

size_t CreatorObject::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition += m_nested_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_text_);
    endBitPosition += m_nestedArray_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_textArray_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isExternArraySet())
    {
        endBitPosition += m_externArray_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isBytesArraySet())
    {
        endBitPosition += m_bytesArray_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isOptionalBoolSet())
    {
        endBitPosition += UINT8_C(1);
    }
    endBitPosition += 1;
    if (isOptionalNestedSet())
    {
        endBitPosition += m_optionalNested_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t CreatorObject::bitSizeOf(CreatorObject::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getValue().bitSizeOf<::zserio::StdIntArrayTraits<uint32_t>>(m_value_);
    endBitPosition += m_nested_.bitSizeOf(context.getNested(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_text_);
    endBitPosition += m_nestedArray_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_textArray_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isExternArraySet())
    {
        endBitPosition += m_externArray_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isBytesArraySet())
    {
        endBitPosition += m_bytesArray_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isOptionalBoolSet())
    {
        endBitPosition += UINT8_C(1);
    }
    endBitPosition += 1;
    if (isOptionalNestedSet())
    {
        endBitPosition += m_optionalNested_.value().bitSizeOf(context.getOptionalNested(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t CreatorObject::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition = m_nested_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_text_);
    endBitPosition = m_nestedArray_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_textArray_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isExternArraySet())
    {
        endBitPosition = m_externArray_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isBytesArraySet())
    {
        endBitPosition = m_bytesArray_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isOptionalBoolSet())
    {
        endBitPosition += UINT8_C(1);
    }
    endBitPosition += 1;
    if (isOptionalNestedSet())
    {
        endBitPosition = m_optionalNested_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t CreatorObject::initializeOffsets(CreatorObject::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getValue().bitSizeOf<::zserio::StdIntArrayTraits<uint32_t>>(m_value_);
    endBitPosition = m_nested_.initializeOffsets(context.getNested(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_text_);
    endBitPosition = m_nestedArray_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_textArray_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isExternArraySet())
    {
        endBitPosition = m_externArray_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isBytesArraySet())
    {
        endBitPosition = m_bytesArray_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isOptionalBoolSet())
    {
        endBitPosition += UINT8_C(1);
    }
    endBitPosition += 1;
    if (isOptionalNestedSet())
    {
        endBitPosition = m_optionalNested_.value().initializeOffsets(context.getOptionalNested(), endBitPosition);
    }

    return endBitPosition;
}

bool CreatorObject::operator==(const CreatorObject& other) const
{
    if (this != &other)
    {
        return
                (m_value_ == other.m_value_) &&
                (m_nested_ == other.m_nested_) &&
                (m_text_ == other.m_text_) &&
                (m_nestedArray_ == other.m_nestedArray_) &&
                (m_textArray_ == other.m_textArray_) &&
                (!isExternArrayUsed() ? !other.isExternArrayUsed() : (m_externArray_ == other.m_externArray_)) &&
                (!isBytesArrayUsed() ? !other.isBytesArrayUsed() : (m_bytesArray_ == other.m_bytesArray_)) &&
                (!isOptionalBoolUsed() ? !other.isOptionalBoolUsed() : (m_optionalBool_ == other.m_optionalBool_)) &&
                (!isOptionalNestedUsed() ? !other.isOptionalNestedUsed() : (m_optionalNested_ == other.m_optionalNested_));
    }

    return true;
}

uint32_t CreatorObject::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_value_);
    result = ::zserio::calcHashCode(result, m_nested_);
    result = ::zserio::calcHashCode(result, m_text_);
    result = ::zserio::calcHashCode(result, m_nestedArray_);
    result = ::zserio::calcHashCode(result, m_textArray_);
    if (isExternArrayUsed())
        result = ::zserio::calcHashCode(result, m_externArray_);
    if (isBytesArrayUsed())
        result = ::zserio::calcHashCode(result, m_bytesArray_);
    if (isOptionalBoolUsed())
        result = ::zserio::calcHashCode(result, m_optionalBool_);
    if (isOptionalNestedUsed())
        result = ::zserio::calcHashCode(result, m_optionalNested_);

    return result;
}

void CreatorObject::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value_, UINT8_C(32));

    // check parameters
    if (m_nested_.getParam() != static_cast<uint32_t>(getValue()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter param for field CreatorObject.nested: ") <<
                m_nested_.getParam() << " != " << static_cast<uint32_t>(getValue()) << "!";
    }
    m_nested_.write(out);

    out.writeString(m_text_);

    m_nestedArray_.write(*this, out);

    m_textArray_.write(out);

    if (isExternArraySet())
    {
        out.writeBool(true);
        m_externArray_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isBytesArraySet())
    {
        out.writeBool(true);
        m_bytesArray_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isOptionalBoolSet())
    {
        out.writeBool(true);
        out.writeBool(m_optionalBool_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isOptionalNestedSet())
    {
        out.writeBool(true);
        // check parameters
        if (m_optionalNested_.value().getParam() != static_cast<uint32_t>(getValue()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter param for field CreatorObject.optionalNested: ") <<
                    m_optionalNested_.value().getParam() << " != " << static_cast<uint32_t>(getValue()) << "!";
        }
        m_optionalNested_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void CreatorObject::write(CreatorObject::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getValue().write<::zserio::StdIntArrayTraits<uint32_t>>(out, m_value_);

    // check parameters
    if (m_nested_.getParam() != static_cast<uint32_t>(getValue()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter param for field CreatorObject.nested: ") <<
                m_nested_.getParam() << " != " << static_cast<uint32_t>(getValue()) << "!";
    }
    m_nested_.write(context.getNested(), out);

    out.writeString(m_text_);

    m_nestedArray_.writePacked(*this, out);

    m_textArray_.write(out);

    if (isExternArraySet())
    {
        out.writeBool(true);
        m_externArray_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isBytesArraySet())
    {
        out.writeBool(true);
        m_bytesArray_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isOptionalBoolSet())
    {
        out.writeBool(true);
        out.writeBool(m_optionalBool_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isOptionalNestedSet())
    {
        out.writeBool(true);
        // check parameters
        if (m_optionalNested_.value().getParam() != static_cast<uint32_t>(getValue()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter param for field CreatorObject.optionalNested: ") <<
                    m_optionalNested_.value().getParam() << " != " << static_cast<uint32_t>(getValue()) << "!";
        }
        m_optionalNested_.value().write(context.getOptionalNested(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

void CreatorObject::ZserioArrayExpressions_nestedArray::initializeElement(CreatorObject& owner,
        ::test_object::polymorphic_allocator::CreatorNested& element, size_t)
{
    element.initialize(static_cast<uint32_t>(owner.getValue()));
}

void CreatorObject::ZserioElementFactory_nestedArray::create(CreatorObject&         owner,
        ::zserio::pmr::vector<::test_object::polymorphic_allocator::CreatorNested>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<uint32_t>(owner.getValue()), array.get_allocator());
}

void CreatorObject::ZserioElementFactory_nestedArray::create(CreatorObject&         owner,
        ::zserio::pmr::vector<::test_object::polymorphic_allocator::CreatorNested>& array,
        ::test_object::polymorphic_allocator::CreatorNested::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<uint32_t>(owner.getValue()), array.get_allocator());
}

uint32_t CreatorObject::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readBits(UINT8_C(32)));
}

uint32_t CreatorObject::readValue(CreatorObject::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getValue().read<::zserio::StdIntArrayTraits<uint32_t>>(in);
}
::test_object::polymorphic_allocator::CreatorNested CreatorObject::readNested(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::test_object::polymorphic_allocator::CreatorNested(in, static_cast<uint32_t>(getValue()), allocator);
}

::test_object::polymorphic_allocator::CreatorNested CreatorObject::readNested(CreatorObject::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::test_object::polymorphic_allocator::CreatorNested(context.getNested(), in, static_cast<uint32_t>(getValue()), allocator);
}
::zserio::pmr::string CreatorObject::readText(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::pmr::string>(in.readString(allocator));
}
CreatorObject::ZserioArrayType_nestedArray CreatorObject::readNestedArray(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_nestedArray readField(allocator);
    readField.read(*this, in);

    return readField;
}

CreatorObject::ZserioArrayType_nestedArray CreatorObject::readNestedArray(CreatorObject::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_nestedArray readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
CreatorObject::ZserioArrayType_textArray CreatorObject::readTextArray(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_textArray readField(allocator);
    readField.read(in);

    return readField;
}
::zserio::InplaceOptionalHolder<CreatorObject::ZserioArrayType_externArray> CreatorObject::readExternArray(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_externArray readField(allocator);
        readField.read(in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_externArray>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_externArray>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<CreatorObject::ZserioArrayType_bytesArray> CreatorObject::readBytesArray(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_bytesArray readField(allocator);
        readField.read(in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_bytesArray>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_bytesArray>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<bool> CreatorObject::readOptionalBool(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<bool>(static_cast<bool>(in.readBool()));
    }

    return ::zserio::InplaceOptionalHolder<bool>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::test_object::polymorphic_allocator::CreatorNested> CreatorObject::readOptionalNested(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::test_object::polymorphic_allocator::CreatorNested>(::test_object::polymorphic_allocator::CreatorNested(in, static_cast<uint32_t>(getValue()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::test_object::polymorphic_allocator::CreatorNested>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::test_object::polymorphic_allocator::CreatorNested> CreatorObject::readOptionalNested(CreatorObject::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::test_object::polymorphic_allocator::CreatorNested>(::test_object::polymorphic_allocator::CreatorNested(context.getOptionalNested(), in, static_cast<uint32_t>(getValue()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::test_object::polymorphic_allocator::CreatorNested>(::zserio::NullOpt);
}

} // namespace polymorphic_allocator
} // namespace test_object
