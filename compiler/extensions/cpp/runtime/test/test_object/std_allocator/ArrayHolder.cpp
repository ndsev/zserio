/**
 * Automatically generated by Zserio C++ generator version 1.0.2 using Zserio core 2.14.1.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, typeInfoCode, reflectionCode, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/TypeInfo.h>
#include <zserio/AnyHolder.h>
#include <zserio/Reflectable.h>

#include <test_object/std_allocator/ArrayHolder.h>

namespace test_object
{
namespace std_allocator
{

ArrayHolder::ArrayHolder(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_enumArray_(allocator),
        m_bitmaskArray_(allocator),
        m_packedArray_(allocator),
        m_packedParamArray_(allocator)
{
}

ArrayHolder::ArrayHolder(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_enumArray_(readEnumArray(in, allocator)),
        m_bitmaskArray_(readBitmaskArray(in, allocator)),
        m_packedArray_(readPackedArray(in, allocator)),
        m_packedParamArray_(readPackedParamArray(in, allocator))
{
}

ArrayHolder::ArrayHolder(const ArrayHolder& other) :
        m_enumArray_(other.m_enumArray_),
        m_bitmaskArray_(other.m_bitmaskArray_),
        m_packedArray_(other.m_packedArray_),
        m_packedParamArray_(::zserio::NoInit, other.m_packedParamArray_)
{
    if (other.m_areChildrenInitialized)
    {
        initializeChildren();
    }
    else
    {
        m_areChildrenInitialized = false;
    }
}

ArrayHolder& ArrayHolder::operator=(const ArrayHolder& other)
{
    m_enumArray_ = other.m_enumArray_;
    m_bitmaskArray_ = other.m_bitmaskArray_;
    m_packedArray_ = other.m_packedArray_;
    (void)m_packedParamArray_.assign(::zserio::NoInit, other.m_packedParamArray_);
    if (other.m_areChildrenInitialized)
    {
        initializeChildren();
    }
    else
    {
        m_areChildrenInitialized = false;
    }

    return *this;
}

ArrayHolder::ArrayHolder(ArrayHolder&& other) :
        m_enumArray_(::std::move(other.m_enumArray_)),
        m_bitmaskArray_(::std::move(other.m_bitmaskArray_)),
        m_packedArray_(::std::move(other.m_packedArray_)),
        m_packedParamArray_(::zserio::NoInit, ::std::move(other.m_packedParamArray_))
{
    if (other.m_areChildrenInitialized)
    {
        initializeChildren();
    }
    else
    {
        m_areChildrenInitialized = false;
    }
}

ArrayHolder& ArrayHolder::operator=(ArrayHolder&& other)
{
    m_enumArray_ = ::std::move(other.m_enumArray_);
    m_bitmaskArray_ = ::std::move(other.m_bitmaskArray_);
    m_packedArray_ = ::std::move(other.m_packedArray_);
    (void)m_packedParamArray_.assign(::zserio::NoInit, ::std::move(other.m_packedParamArray_));
    if (other.m_areChildrenInitialized)
    {
        initializeChildren();
    }
    else
    {
        m_areChildrenInitialized = false;
    }

    return *this;
}

ArrayHolder::ArrayHolder(::zserio::PropagateAllocatorT,
        const ArrayHolder& other, const allocator_type& allocator) :
        m_enumArray_(::zserio::allocatorPropagatingCopy(other.m_enumArray_, allocator)),
        m_bitmaskArray_(::zserio::allocatorPropagatingCopy(other.m_bitmaskArray_, allocator)),
        m_packedArray_(::zserio::allocatorPropagatingCopy(other.m_packedArray_, allocator)),
        m_packedParamArray_(::zserio::NoInit, ::zserio::allocatorPropagatingCopy(::zserio::NoInit, other.m_packedParamArray_, allocator))
{
    if (other.m_areChildrenInitialized)
    {
        initializeChildren();
    }
    else
    {
        m_areChildrenInitialized = false;
    }
}

const ::zserio::ITypeInfo& ArrayHolder::typeInfo()
{
    static const ::zserio::StringView templateName;
    static const ::zserio::Span<::zserio::BasicTemplateArgumentInfo<allocator_type>> templateArguments;

    static const ::std::array<::zserio::StringView, 1> packedParamArrayTypeArguments = {
        ::zserio::makeStringView("getPackedArray().at(index)")
    };
    static const ::std::array<::zserio::BasicFieldInfo<allocator_type>, 4> fields = {
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("enumArray"), // schemaName
            ::zserio::enumTypeInfo<::test_object::std_allocator::ArrayEnum, allocator_type>(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            true, // isArray
            {}, // arrayLength
            true, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("bitmaskArray"), // schemaName
            ::test_object::std_allocator::ArrayBitmask::typeInfo(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            true, // isArray
            {}, // arrayLength
            true, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("packedArray"), // schemaName
            ::test_object::std_allocator::ArrayObject::typeInfo(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            true, // isArray
            {}, // arrayLength
            true, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("packedParamArray"), // schemaName
            ::test_object::std_allocator::ArrayParamObject::typeInfo(), // typeInfo
            packedParamArrayTypeArguments, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            true, // isArray
            {}, // arrayLength
            true, // isPacked
            false // isImplicit
        }
    };

    static const ::zserio::Span<::zserio::BasicParameterInfo<allocator_type>> parameters;

    static const ::zserio::Span<::zserio::BasicFunctionInfo<allocator_type>> functions;

    static const ::zserio::StructTypeInfo<allocator_type> typeInfo = {
        ::zserio::makeStringView("test_object.std_allocator.ArrayHolder"),
        [](const allocator_type& allocator) -> ::zserio::IReflectablePtr
        {
            return std::allocate_shared<::zserio::ReflectableOwner<ArrayHolder>>(allocator, allocator);
        },
        templateName, templateArguments,
        fields, parameters, functions
    };

    return typeInfo;
}

::zserio::IReflectableConstPtr ArrayHolder::reflectable(const allocator_type& allocator) const
{
    class Reflectable : public ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>
    {
    public:
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::getField;
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::getParameter;
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::callFunction;
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::getAnyValue;

        explicit Reflectable(const ::test_object::std_allocator::ArrayHolder& object, const allocator_type& alloc) :
                ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>(::test_object::std_allocator::ArrayHolder::typeInfo(), alloc),
                m_object(object)
        {}

        size_t bitSizeOf(size_t bitPosition) const override
        {
            return m_object.bitSizeOf(bitPosition);
        }

        void write(::zserio::BitStreamWriter& writer) const override
        {
            m_object.write(writer);
        }

        ::zserio::IReflectableConstPtr getField(::zserio::StringView name) const override
        {
            if (name == ::zserio::makeStringView("enumArray"))
            {
                return ::zserio::ReflectableFactory::getEnumArray(m_object.getEnumArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("bitmaskArray"))
            {
                return ::zserio::ReflectableFactory::getBitmaskArray(m_object.getBitmaskArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("packedArray"))
            {
                return ::zserio::ReflectableFactory::getCompoundArray(m_object.getPackedArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("packedParamArray"))
            {
                return ::zserio::ReflectableFactory::getCompoundArray(m_object.getPackedParamArray(), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'ArrayHolder'!";
        }

        ::zserio::AnyHolder<> getAnyValue(const allocator_type& alloc) const override
        {
            return ::zserio::AnyHolder<>(::std::cref(m_object), alloc);
        }

    private:
        const ::test_object::std_allocator::ArrayHolder& m_object;
    };

    return std::allocate_shared<Reflectable>(allocator, *this, allocator);
}

::zserio::IReflectablePtr ArrayHolder::reflectable(const allocator_type& allocator)
{
    class Reflectable : public ::zserio::ReflectableAllocatorHolderBase<allocator_type>
    {
    public:
        explicit Reflectable(::test_object::std_allocator::ArrayHolder& object, const allocator_type& alloc) :
                ::zserio::ReflectableAllocatorHolderBase<allocator_type>(::test_object::std_allocator::ArrayHolder::typeInfo(), alloc),
                m_object(object)
        {}

        void initializeChildren() override
        {
            m_object.initializeChildren();
        }

        size_t initializeOffsets(size_t bitPosition) override
        {
            return m_object.initializeOffsets(bitPosition);
        }

        size_t bitSizeOf(size_t bitPosition) const override
        {
            return m_object.bitSizeOf(bitPosition);
        }

        void write(::zserio::BitStreamWriter& writer) const override
        {
            m_object.write(writer);
        }

        ::zserio::IReflectableConstPtr getField(::zserio::StringView name) const override
        {
            if (name == ::zserio::makeStringView("enumArray"))
            {
                return ::zserio::ReflectableFactory::getEnumArray(m_object.getEnumArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("bitmaskArray"))
            {
                return ::zserio::ReflectableFactory::getBitmaskArray(m_object.getBitmaskArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("packedArray"))
            {
                return ::zserio::ReflectableFactory::getCompoundArray(m_object.getPackedArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("packedParamArray"))
            {
                return ::zserio::ReflectableFactory::getCompoundArray(m_object.getPackedParamArray(), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'ArrayHolder'!";
        }

        ::zserio::IReflectablePtr getField(::zserio::StringView name) override
        {
            if (name == ::zserio::makeStringView("enumArray"))
            {
                return ::zserio::ReflectableFactory::getEnumArray(m_object.getEnumArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("bitmaskArray"))
            {
                return ::zserio::ReflectableFactory::getBitmaskArray(m_object.getBitmaskArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("packedArray"))
            {
                return ::zserio::ReflectableFactory::getCompoundArray(m_object.getPackedArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("packedParamArray"))
            {
                return ::zserio::ReflectableFactory::getCompoundArray(m_object.getPackedParamArray(), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'ArrayHolder'!";
        }

        void setField(::zserio::StringView name,
                const ::zserio::AnyHolder<allocator_type>& value) override
        {
            if (name == ::zserio::makeStringView("enumArray"))
            {
                m_object.setEnumArray(value.get<::zserio::vector<::test_object::std_allocator::ArrayEnum>>());
                return;
            }
            if (name == ::zserio::makeStringView("bitmaskArray"))
            {
                m_object.setBitmaskArray(value.get<::zserio::vector<::test_object::std_allocator::ArrayBitmask>>());
                return;
            }
            if (name == ::zserio::makeStringView("packedArray"))
            {
                m_object.setPackedArray(value.get<::zserio::vector<::test_object::std_allocator::ArrayObject>>());
                return;
            }
            if (name == ::zserio::makeStringView("packedParamArray"))
            {
                m_object.setPackedParamArray(value.get<::zserio::vector<::test_object::std_allocator::ArrayParamObject>>());
                return;
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'ArrayHolder'!";
        }

        ::zserio::IReflectablePtr createField(::zserio::StringView name) override
        {
            if (name == ::zserio::makeStringView("enumArray"))
            {
                m_object.setEnumArray(::zserio::vector<::test_object::std_allocator::ArrayEnum>(get_allocator()));
                return ::zserio::ReflectableFactory::getEnumArray(m_object.getEnumArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("bitmaskArray"))
            {
                m_object.setBitmaskArray(::zserio::vector<::test_object::std_allocator::ArrayBitmask>(get_allocator()));
                return ::zserio::ReflectableFactory::getBitmaskArray(m_object.getBitmaskArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("packedArray"))
            {
                m_object.setPackedArray(::zserio::vector<::test_object::std_allocator::ArrayObject>(get_allocator()));
                return ::zserio::ReflectableFactory::getCompoundArray(m_object.getPackedArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("packedParamArray"))
            {
                m_object.setPackedParamArray(::zserio::vector<::test_object::std_allocator::ArrayParamObject>(get_allocator()));
                return ::zserio::ReflectableFactory::getCompoundArray(m_object.getPackedParamArray(), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'ArrayHolder'!";
        }

        ::zserio::AnyHolder<> getAnyValue(const allocator_type& alloc) const override
        {
            return ::zserio::AnyHolder<>(::std::cref(m_object), alloc);
        }

        ::zserio::AnyHolder<> getAnyValue(const allocator_type& alloc) override
        {
            return ::zserio::AnyHolder<>(::std::ref(m_object), alloc);
        }

    private:
        ::test_object::std_allocator::ArrayHolder& m_object;
    };

    return std::allocate_shared<Reflectable>(allocator, *this, allocator);
}

void ArrayHolder::initializeChildren()
{
    m_packedParamArray_.initializeElements(*this);

    m_areChildrenInitialized = true;
}

::zserio::vector<::test_object::std_allocator::ArrayEnum>& ArrayHolder::getEnumArray()
{
    return m_enumArray_.getRawArray();
}

const ::zserio::vector<::test_object::std_allocator::ArrayEnum>& ArrayHolder::getEnumArray() const
{
    return m_enumArray_.getRawArray();
}

void ArrayHolder::setEnumArray(const ::zserio::vector<::test_object::std_allocator::ArrayEnum>& enumArray_)
{
    m_enumArray_ = ZserioArrayType_enumArray(enumArray_);
}

void ArrayHolder::setEnumArray(::zserio::vector<::test_object::std_allocator::ArrayEnum>&& enumArray_)
{
    m_enumArray_ = ZserioArrayType_enumArray(std::move(enumArray_));
}

::zserio::vector<::test_object::std_allocator::ArrayBitmask>& ArrayHolder::getBitmaskArray()
{
    return m_bitmaskArray_.getRawArray();
}

const ::zserio::vector<::test_object::std_allocator::ArrayBitmask>& ArrayHolder::getBitmaskArray() const
{
    return m_bitmaskArray_.getRawArray();
}

void ArrayHolder::setBitmaskArray(const ::zserio::vector<::test_object::std_allocator::ArrayBitmask>& bitmaskArray_)
{
    m_bitmaskArray_ = ZserioArrayType_bitmaskArray(bitmaskArray_);
}

void ArrayHolder::setBitmaskArray(::zserio::vector<::test_object::std_allocator::ArrayBitmask>&& bitmaskArray_)
{
    m_bitmaskArray_ = ZserioArrayType_bitmaskArray(std::move(bitmaskArray_));
}

::zserio::vector<::test_object::std_allocator::ArrayObject>& ArrayHolder::getPackedArray()
{
    return m_packedArray_.getRawArray();
}

const ::zserio::vector<::test_object::std_allocator::ArrayObject>& ArrayHolder::getPackedArray() const
{
    return m_packedArray_.getRawArray();
}

void ArrayHolder::setPackedArray(const ::zserio::vector<::test_object::std_allocator::ArrayObject>& packedArray_)
{
    m_packedArray_ = ZserioArrayType_packedArray(packedArray_);
}

void ArrayHolder::setPackedArray(::zserio::vector<::test_object::std_allocator::ArrayObject>&& packedArray_)
{
    m_packedArray_ = ZserioArrayType_packedArray(std::move(packedArray_));
}

::zserio::vector<::test_object::std_allocator::ArrayParamObject>& ArrayHolder::getPackedParamArray()
{
    return m_packedParamArray_.getRawArray();
}

const ::zserio::vector<::test_object::std_allocator::ArrayParamObject>& ArrayHolder::getPackedParamArray() const
{
    return m_packedParamArray_.getRawArray();
}

void ArrayHolder::setPackedParamArray(const ::zserio::vector<::test_object::std_allocator::ArrayParamObject>& packedParamArray_)
{
    m_packedParamArray_ = ZserioArrayType_packedParamArray(packedParamArray_);
}

void ArrayHolder::setPackedParamArray(::zserio::vector<::test_object::std_allocator::ArrayParamObject>&& packedParamArray_)
{
    m_packedParamArray_ = ZserioArrayType_packedParamArray(std::move(packedParamArray_));
}

size_t ArrayHolder::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_enumArray_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_bitmaskArray_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_packedArray_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_packedParamArray_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ArrayHolder::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_enumArray_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_bitmaskArray_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_packedArray_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_packedParamArray_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ArrayHolder::operator==(const ArrayHolder& other) const
{
    if (this != &other)
    {
        return
                (m_enumArray_ == other.m_enumArray_) &&
                (m_bitmaskArray_ == other.m_bitmaskArray_) &&
                (m_packedArray_ == other.m_packedArray_) &&
                (m_packedParamArray_ == other.m_packedParamArray_);
    }

    return true;
}

bool ArrayHolder::operator<(const ArrayHolder& other) const
{
    if (m_enumArray_ < other.m_enumArray_)
    {
        return true;
    }
    if (other.m_enumArray_ < m_enumArray_)
    {
        return false;
    }

    if (m_bitmaskArray_ < other.m_bitmaskArray_)
    {
        return true;
    }
    if (other.m_bitmaskArray_ < m_bitmaskArray_)
    {
        return false;
    }

    if (m_packedArray_ < other.m_packedArray_)
    {
        return true;
    }
    if (other.m_packedArray_ < m_packedArray_)
    {
        return false;
    }

    if (m_packedParamArray_ < other.m_packedParamArray_)
    {
        return true;
    }
    if (other.m_packedParamArray_ < m_packedParamArray_)
    {
        return false;
    }

    return false;
}

uint32_t ArrayHolder::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_enumArray_);
    result = ::zserio::calcHashCode(result, m_bitmaskArray_);
    result = ::zserio::calcHashCode(result, m_packedArray_);
    result = ::zserio::calcHashCode(result, m_packedParamArray_);

    return result;
}

void ArrayHolder::write(::zserio::BitStreamWriter& out) const
{
    m_enumArray_.writePacked(out);
    m_bitmaskArray_.writePacked(out);
    m_packedArray_.writePacked(*this, out);
    m_packedParamArray_.writePacked(*this, out);
}

void ArrayHolder::ZserioElementFactory_packedArray::create(ArrayHolder&,
        ::zserio::vector<::test_object::std_allocator::ArrayObject>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ArrayHolder::ZserioElementFactory_packedArray::create(ArrayHolder&,
        ::zserio::vector<::test_object::std_allocator::ArrayObject>& array,
        ::test_object::std_allocator::ArrayObject::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void ArrayHolder::ZserioArrayExpressions_packedParamArray::initializeElement(ArrayHolder& owner,
        ::test_object::std_allocator::ArrayParamObject& element, size_t index)
{
    element.initialize(owner.getPackedArray().at(index));
}

void ArrayHolder::ZserioElementFactory_packedParamArray::create(ArrayHolder& owner,
        ::zserio::vector<::test_object::std_allocator::ArrayParamObject>& array,
        ::zserio::BitStreamReader& in, size_t index)
{
    array.emplace_back(in, owner.getPackedArray().at(index), array.get_allocator());
}

void ArrayHolder::ZserioElementFactory_packedParamArray::create(ArrayHolder& owner,
        ::zserio::vector<::test_object::std_allocator::ArrayParamObject>& array,
        ::test_object::std_allocator::ArrayParamObject::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t index)
{
    array.emplace_back(context, in, owner.getPackedArray().at(index), array.get_allocator());
}

ArrayHolder::ZserioArrayType_enumArray ArrayHolder::readEnumArray(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_enumArray readField(allocator);
    readField.readPacked(in);

    return readField;
}

ArrayHolder::ZserioArrayType_bitmaskArray ArrayHolder::readBitmaskArray(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_bitmaskArray readField(allocator);
    readField.readPacked(in);

    return readField;
}

ArrayHolder::ZserioArrayType_packedArray ArrayHolder::readPackedArray(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_packedArray readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

ArrayHolder::ZserioArrayType_packedParamArray ArrayHolder::readPackedParamArray(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_packedParamArray readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}


} // namespace std_allocator
} // namespace test_object
