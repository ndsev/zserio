<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FloatUtilTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Zserio Java Runtime Library</a> &gt; <a href="index.source.html" class="el_package">zserio.runtime</a> &gt; <span class="el_source">FloatUtilTest.java</span></div><h1>FloatUtilTest.java</h1><pre class="source lang-java linenums">package zserio.runtime;

import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;

<span class="fc" id="L6">public class FloatUtilTest</span>
{
    @Test
    public void convertShortToFloat()
    {
        // plus zero
<span class="fc" id="L12">        final short float16ValuePlusZero = createFloat16Value((short) 0, (short) 0, (short) 0); // +0.0</span>
<span class="fc" id="L13">        checkFloat16ToFloat32Conversion(float16ValuePlusZero, 0.0f);</span>

        // minus zero
<span class="fc" id="L16">        final short float16ValueMinusZero = createFloat16Value((short) 1, (short) 0, (short) 0); // -0.0</span>
<span class="fc" id="L17">        checkFloat16ToFloat32Conversion(float16ValueMinusZero, -0.0f);</span>

        // plus infinity
<span class="fc" id="L20">        final short float16ValuePlusInfinity = createFloat16Value((short) 0, (short) 0x1F, (short) 0); // +INF</span>
<span class="fc" id="L21">        final int float32ValuePlusInfinity = createFloat32Value(0, 0xFF, 0); // +INF</span>
<span class="fc" id="L22">        checkFloat16ToFloat32Conversion(float16ValuePlusInfinity, float32ValuePlusInfinity);</span>

        // minus infinity
<span class="fc" id="L25">        final short float16ValueMinusInfinity = createFloat16Value((short) 1, (short) 0x1F, (short) 0); // -INF</span>
<span class="fc" id="L26">        final int float32ValueMinusInfinity = createFloat32Value(1, 0xFF, 0); // -INF</span>
<span class="fc" id="L27">        checkFloat16ToFloat32Conversion(float16ValueMinusInfinity, float32ValueMinusInfinity);</span>

        // quiet NaN (Java uses only the 1st significand bit in NaN)
<span class="fc" id="L30">        final short float16ValueQuietNan = createFloat16Value((short) 0, (short) 0x1F, (short) 0x3FF); // +NaN</span>
<span class="fc" id="L31">        final int float32ValueQuietNan = createFloat32Value(0, 0xFF, 0x400000); // +NaN</span>
<span class="fc" id="L32">        checkFloat16ToFloat32Conversion(float16ValueQuietNan, float32ValueQuietNan);</span>

        // signaling NaN (Java uses only quiet NaN)
                                               // -NaN
<span class="fc" id="L36">        final short float16ValueSignalingNan = createFloat16Value((short) 1, (short) 0x1F, (short) 0x3FF);</span>
<span class="fc" id="L37">        checkFloat16ToFloat32Conversion(float16ValueSignalingNan, float32ValueQuietNan);</span>

        // normal numbers
<span class="fc" id="L40">        final short float16ValueOne = createFloat16Value((short) 0, (short) 15, (short) 0); // 1.0</span>
<span class="fc" id="L41">        checkFloat16ToFloat32Conversion(float16ValueOne, 1.0f);</span>

                                          // 1.0 + 2^-10
<span class="fc" id="L44">        final short float16ValueOnePlus = createFloat16Value((short) 0, (short) 15, (short) 0x01);</span>
                                        // 1.0 + 2^-10
<span class="fc" id="L46">        final int float32ValueOnePlus = createFloat32Value(0, 127, 0x2000);</span>
<span class="fc" id="L47">        checkFloat16ToFloat32Conversion(float16ValueOnePlus, float32ValueOnePlus);</span>

                                      // 2^15 (1 + 2^-1 + ... + 2^-10)
<span class="fc" id="L50">        final short float16ValueMax = createFloat16Value((short) 0, (short) 30, (short) 0x3FF);</span>
<span class="fc" id="L51">        checkFloat16ToFloat32Conversion(float16ValueMax, 65504.0f);</span>

        // subnormal numbers
                                               // 2^-14 (2^-10)
<span class="fc" id="L55">        final short float16ValueMinSubnormal = createFloat16Value((short) 0, (short) 0, (short) 1);</span>
                                             // 2^-24
<span class="fc" id="L57">        final int float32ValueMinSubnormal = createFloat32Value(0, 103, 0);</span>
<span class="fc" id="L58">        checkFloat16ToFloat32Conversion(float16ValueMinSubnormal, float32ValueMinSubnormal);</span>

                                               // 2^-14 (2^-1 + ... + 2^-10)
<span class="fc" id="L61">        final short float16ValueMaxSubnormal = createFloat16Value((short) 0, (short) 0, (short) 0x3FF);</span>
                                             // 2^-15 (1 + 2^-1 + ... + 2^-9)
<span class="fc" id="L63">        final int float32ValueMaxSubnormal = createFloat32Value(0, 112, 0x7FC000);</span>
<span class="fc" id="L64">        checkFloat16ToFloat32Conversion(float16ValueMaxSubnormal, float32ValueMaxSubnormal);</span>
<span class="fc" id="L65">    }</span>

    @Test
    public void convertFloatToShort()
    {
        // plus zero
<span class="fc" id="L71">        final short float16ValuePlusZero = createFloat16Value((short) 0, (short) 0, (short) 0); // +0.0</span>
<span class="fc" id="L72">        checkFloat32ToFloat16Conversion(0.0f, float16ValuePlusZero);</span>

        // minus zero
<span class="fc" id="L75">        final short float16ValueMinusZero = createFloat16Value((short) 1, (short) 0, (short) 0); // -0.0</span>
<span class="fc" id="L76">        checkFloat32ToFloat16Conversion(-0.0f, float16ValueMinusZero);</span>

        // plus infinity
<span class="fc" id="L79">        final int float32ValuePlusInfinity = createFloat32Value(0, 0xFF, 0); // +INF</span>
<span class="fc" id="L80">        final short float16ValuePlusInfinity = createFloat16Value((short) 0, (short) 0x1F, (short) 0); // +INF</span>
<span class="fc" id="L81">        checkFloat32ToFloat16Conversion(float32ValuePlusInfinity, float16ValuePlusInfinity);</span>

        // minus infinity
<span class="fc" id="L84">        final int float32ValueMinusInfinity = createFloat32Value(1, 0xFF, 0); // -INF</span>
<span class="fc" id="L85">        final short float16ValueMinusInfinity = createFloat16Value((short) 1, (short) 0x1F, (short) 0); // -INF</span>
<span class="fc" id="L86">        checkFloat32ToFloat16Conversion(float32ValueMinusInfinity, float16ValueMinusInfinity);</span>

        // quiet NaN (Java uses only the 1st significand bit in NaN)
<span class="fc" id="L89">        final int float32ValueQuietNan = createFloat32Value(0, 0xFF, 0x7FE000); // +NaN</span>
<span class="fc" id="L90">        final short float16ValueQuietNan = createFloat16Value((short) 0, (short) 0x1F, (short) 0x200); // +NaN</span>
<span class="fc" id="L91">        checkFloat32ToFloat16Conversion(float32ValueQuietNan, float16ValueQuietNan);</span>

        // signaling NaN (Java uses only quiet NaN)
<span class="fc" id="L94">        final int float32ValueSignalingNan = createFloat32Value(1, 0xFF, 0x7FE000); // -NaN</span>
<span class="fc" id="L95">        checkFloat32ToFloat16Conversion(float32ValueSignalingNan, float16ValueQuietNan);</span>

        // normal numbers
<span class="fc" id="L98">        final short float16ValueOne = createFloat16Value((short) 0, (short) 15, (short) 0); // 1.0</span>
<span class="fc" id="L99">        checkFloat32ToFloat16Conversion(1.0f, float16ValueOne);</span>

<span class="fc" id="L101">        final int float32ValueOnePlus = createFloat32Value(0, 127, 0x2000); // 1.0 + 2^-10</span>
<span class="fc" id="L102">        final short float16ValueOnePlus = createFloat16Value((short) 0, (short) 15, (short) 0x01); // 1.0 + 2^-10</span>
<span class="fc" id="L103">        checkFloat32ToFloat16Conversion(float32ValueOnePlus, float16ValueOnePlus);</span>

<span class="fc" id="L105">        final short float16ValueMax = createFloat16Value((short) 0, (short) 30, (short) 0x3FF); // 2^15 (1 + 2^-1 + ... + 2^-10)</span>
<span class="fc" id="L106">        checkFloat32ToFloat16Conversion(65504.0f, float16ValueMax);</span>

        // normal numbers converted to zero
<span class="fc" id="L109">        final int float32ValueUnderflow = createFloat32Value(0, 102, 0); // 2^-25</span>
<span class="fc" id="L110">        checkFloat32ToFloat16Conversion(float32ValueUnderflow, float16ValuePlusZero);</span>

        // normal numbers converted to subnormal numbers
<span class="fc" id="L113">        final int float32ValueMinUnderflow = createFloat32Value(0, 103, 1);  // 2^-24 (1 + 2^-23)</span>
<span class="fc" id="L114">        final short float16ValueMinSubnormal = createFloat16Value((short) 0, (short) 0, (short) 1);    // 2^-24</span>
<span class="fc" id="L115">        checkFloat32ToFloat16Conversion(float32ValueMinUnderflow, float16ValueMinSubnormal);</span>

        // normal numbers converted to subnormal numbers with rounding
<span class="fc" id="L118">        final int float32ValueMinUnderflowRounding = createFloat32Value(0, 104, 0x200000); // 2^-23 (1 + 2^-2)</span>
<span class="fc" id="L119">        final short float16ValueMinSubnormalRounding = createFloat16Value((short) 0, (short) 0, (short) 0x3); // 2^-14 (2^-9 + 2^-10)</span>
<span class="fc" id="L120">        checkFloat32ToFloat16Conversion(float32ValueMinUnderflowRounding, float16ValueMinSubnormalRounding);</span>

        // normal numbers converted to infinity
<span class="fc" id="L123">        final int float32ValueOverflow = createFloat32Value(0, 144, 0); // 2^17</span>
<span class="fc" id="L124">        checkFloat32ToFloat16Conversion(float32ValueOverflow, float16ValuePlusInfinity);</span>

        // normal numbers converted with rounding
<span class="fc" id="L127">        final int float32ValueRounding = createFloat32Value(0, 127, 0x401000); // 1 + 2^-1 + 2^-11</span>
<span class="fc" id="L128">        final short float16ValueRounding = createFloat16Value((short) 0, (short) 15, (short) 0x201);     // 1 + 2^-1 + 2^-10</span>
<span class="fc" id="L129">        checkFloat32ToFloat16Conversion(float32ValueRounding, float16ValueRounding);</span>

        // subnormal numbers
<span class="fc" id="L132">        final int float32ValueMinSubnormal = createFloat32Value(0, 0, 1); // 2^-126 (2^-23)</span>
<span class="fc" id="L133">        checkFloat32ToFloat16Conversion(float32ValueMinSubnormal, float16ValuePlusZero);</span>

                                                                               // 2^-126 (2^-1 + ... + 2^-23)
<span class="fc" id="L136">        final int float32ValueMaxSubnormal = createFloat32Value(0, 0, 0x007FFFFF);</span>
<span class="fc" id="L137">        checkFloat32ToFloat16Conversion(float32ValueMaxSubnormal, float16ValuePlusZero);</span>
<span class="fc" id="L138">    }</span>

    @Test
    public void convertIntToFloat()
    {
<span class="fc bfc" id="L143" title="All 2 branches covered.">        for (TestFloat32Element testElement : TEST_FLOAT32_DATA)</span>
        {
<span class="fc" id="L145">            final int float32Value = createFloat32Value(testElement.sign, testElement.exponent,</span>
                    testElement.significand);
<span class="fc" id="L147">            final float convertedFloat = FloatUtil.convertIntToFloat(float32Value);</span>

<span class="fc" id="L149">            assertEquals(Float.toString(testElement.expectedFloat), Float.toString(convertedFloat));</span>
        }
<span class="fc" id="L151">    }</span>

    @Test
    public void convertFloatToInt()
    {
<span class="fc bfc" id="L156" title="All 2 branches covered.">        for (TestFloat32Element testElement : TEST_FLOAT32_DATA)</span>
        {
<span class="fc" id="L158">            final int convertedFloatValue = FloatUtil.convertFloatToInt(testElement.expectedFloat);</span>
<span class="fc" id="L159">            final int expectedFloatValue = createFloat32Value(testElement.sign, testElement.exponent,</span>
                    testElement.significand);

<span class="fc" id="L162">            assertEquals(expectedFloatValue, convertedFloatValue);</span>
        }
<span class="fc" id="L164">    }</span>

    @Test
    public void convertLongToDouble()
    {
<span class="fc bfc" id="L169" title="All 2 branches covered.">        for (TestFloat64Element testElement : TEST_FLOAT64_DATA)</span>
        {
<span class="fc" id="L171">            final long float64Value = createFloat64Value(testElement.sign, testElement.exponent,</span>
                    testElement.significand);
<span class="fc" id="L173">            final double convertedDouble = FloatUtil.convertLongToDouble(float64Value);</span>

<span class="fc" id="L175">            assertEquals(Double.toString(testElement.expectedDouble), Double.toString(convertedDouble));</span>
        }
<span class="fc" id="L177">    }</span>

    @Test
    public void convertDoubleToLong()
    {
<span class="fc bfc" id="L182" title="All 2 branches covered.">        for (TestFloat64Element testElement : TEST_FLOAT64_DATA)</span>
        {
<span class="fc" id="L184">            final long convertedDoubleValue = FloatUtil.convertDoubleToLong(testElement.expectedDouble);</span>
<span class="fc" id="L185">            final long expectedDoubleValue = createFloat64Value(testElement.sign, testElement.exponent,</span>
                    testElement.significand);

<span class="fc" id="L188">            assertEquals(expectedDoubleValue, convertedDoubleValue);</span>
        }
<span class="fc" id="L190">    }</span>

    private static short createFloat16Value(short sign, short exponent, short significand)
    {
<span class="fc" id="L194">        return (short) ((sign &lt;&lt; FLOAT16_SIGN_BIT_POSITION) | (exponent &lt;&lt; FLOAT16_EXPONENT_BIT_POSITION) |</span>
                significand);
    }

    private static int createFloat32Value(int sign, int exponent, int significand)
    {

<span class="fc" id="L201">        return (sign &lt;&lt; FLOAT32_SIGN_BIT_POSITION) | (exponent &lt;&lt; FLOAT32_EXPONENT_BIT_POSITION) | significand;</span>
    }

    private static long createFloat64Value(long sign, long exponent, long significand)
    {

<span class="fc" id="L207">        return (sign &lt;&lt; FLOAT64_SIGN_BIT_POSITION) | (exponent &lt;&lt; FLOAT64_EXPONENT_BIT_POSITION) | significand;</span>
    }

    private static void checkFloat16ToFloat32Conversion(short float16Value, int expectedFloat32Value)
    {
<span class="fc" id="L212">        final float float32 = FloatUtil.convertShortToFloat(float16Value);</span>
<span class="fc" id="L213">        assertEquals(expectedFloat32Value, Float.floatToIntBits(float32));</span>
<span class="fc" id="L214">    }</span>

    private static void checkFloat16ToFloat32Conversion(short float16Value, float expectedFloat32)
    {
<span class="fc" id="L218">        assertEquals(Float.toString(expectedFloat32),</span>
<span class="fc" id="L219">                Float.toString(FloatUtil.convertShortToFloat(float16Value)));</span>
<span class="fc" id="L220">    }</span>

    private static void checkFloat32ToFloat16Conversion(int float32Value, short expectedFloat16Value)
    {
<span class="fc" id="L224">        final float float32 = Float.intBitsToFloat(float32Value);</span>
<span class="fc" id="L225">        assertEquals(expectedFloat16Value, FloatUtil.convertFloatToShort(float32));</span>
<span class="fc" id="L226">    }</span>

    private static void checkFloat32ToFloat16Conversion(float float32, short expectedFloat16Value)
    {
<span class="fc" id="L230">        assertEquals(expectedFloat16Value, FloatUtil.convertFloatToShort(float32));</span>
<span class="fc" id="L231">    }</span>

    private static class TestFloat32Element
    {
        public TestFloat32Element(int sign, int exponent, int significand, float expectedFloat)
<span class="fc" id="L236">        {</span>
<span class="fc" id="L237">            this.sign = sign;</span>
<span class="fc" id="L238">            this.exponent = exponent;</span>
<span class="fc" id="L239">            this.significand = significand;</span>
<span class="fc" id="L240">            this.expectedFloat = expectedFloat;</span>
<span class="fc" id="L241">        }</span>

        public int      sign;
        public int      exponent;
        public int      significand;
        public float    expectedFloat;
    };

    private static class TestFloat64Element
    {
        public TestFloat64Element(long sign, long exponent, long significand, double expectedDouble)
<span class="fc" id="L252">        {</span>
<span class="fc" id="L253">            this.sign = sign;</span>
<span class="fc" id="L254">            this.exponent = exponent;</span>
<span class="fc" id="L255">            this.significand = significand;</span>
<span class="fc" id="L256">            this.expectedDouble = expectedDouble;</span>
<span class="fc" id="L257">        }</span>

        public long     sign;
        public long     exponent;
        public long     significand;
        public double   expectedDouble;
    };

<span class="fc" id="L265">    private static final TestFloat32Element TEST_FLOAT32_DATA[] =</span>
    {
        new TestFloat32Element(0, 0,   0,         0.0f),
        new TestFloat32Element(1, 0,   0,        -0.0f),
        new TestFloat32Element(0, 127, 0,        +1.0f),
        new TestFloat32Element(1, 127, 0,        -1.0f),
        new TestFloat32Element(0, 128, 0x600000,  3.5f),      // 2^1 (1 + 2^-1 + 2^-2)
        new TestFloat32Element(0, 126, 0x600000,  0.875f),    // 2^-1 (1 + 2^-1 + 2^-2)
        new TestFloat32Element(0, 130, 0x1E0000,  9.875f),    // 2^3 (1 + 2^-3 + 2^-4 + 2^-5 + 2^-6)
        new TestFloat32Element(0, 126, 0x1E0000,  0.6171875f) // 2^-3 (1 + 2^-3 + 2^-4 + 2^-5 + 2^-6)
    };

<span class="fc" id="L277">    private static final TestFloat64Element TEST_FLOAT64_DATA[] =</span>
    {
        new TestFloat64Element(0, 0,    0,                 0.0),
        new TestFloat64Element(1, 0,    0,                -0.0),
        new TestFloat64Element(0, 1023, 0,                +1.0f),
        new TestFloat64Element(1, 1023, 0,                -1.0f),
        new TestFloat64Element(0, 1024, 0xC000000000000L,  3.5f),      // 2^1 (1 + 2^-1 + 2^-2)
        new TestFloat64Element(0, 1022, 0xC000000000000L,  0.875f),    // 2^-1 (1 + 2^-1 + 2^-2)
        new TestFloat64Element(0, 1026, 0x3C00000000000L,  9.875f),    // 2^3 (1 + 2^-3 + 2^-4 + 2^-5 + 2^-6)
        new TestFloat64Element(0, 1022, 0x3C00000000000L,  0.6171875f) // 2^-3 (1 + 2^-3 + 2^-4 + 2^-5 + 2^-6)
    };

    private static final short FLOAT16_SIGN_BIT_POSITION = 15;
    private static final short FLOAT16_EXPONENT_BIT_POSITION = 10;

    private static final int FLOAT32_SIGN_BIT_POSITION = 31;
    private static final int FLOAT32_EXPONENT_BIT_POSITION = 23;

    private static final long FLOAT64_SIGN_BIT_POSITION = 63;
    private static final long FLOAT64_EXPONENT_BIT_POSITION = 52;
};
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>