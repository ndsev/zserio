<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Array.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Zserio Java Runtime Library</a> &gt; <a href="index.source.html" class="el_package">zserio.runtime.array</a> &gt; <span class="el_source">Array.java</span></div><h1>Array.java</h1><pre class="source lang-java linenums">package zserio.runtime.array;

import java.io.IOException;

import zserio.runtime.BitPositionUtil;
import zserio.runtime.BitSizeOfCalculator;
import zserio.runtime.io.BitStreamReader;
import zserio.runtime.io.BitStreamWriter;

/**
 * Array wrapper which is used for mapping of all zserio arrays.
 *
 * Array wrapper is defined by:
 * - raw array
 * - array traits which define zserio methods for array elements of corresponding Java native types
 * - array type (normal, auto, implicit)
 * - offset initializer to set offsets for indexed offsets arrays
 * - offset checker to check offsets for indexed offsets arrays
 */
public class Array
{
    /**
     * Constructor.
     *
     * @param rawArray    Raw array to construct from.
     * @param arrayTraits Array traits to construct from.
     * @param arrayType   Array type to construct from.
     */
    public Array(RawArray rawArray, ArrayTraits arrayTraits, ArrayType arrayType)
    {
<span class="fc" id="L31">        this(rawArray, arrayTraits, arrayType, null, null);</span>
<span class="fc" id="L32">    }</span>

    /**
     * Constructor.
     *
     * @param rawArray      Raw array to construct from.
     * @param arrayTraits   Array traits to construct from.
     * @param arrayType     Array type to construct from.
     * @param offsetChecker Offset checker to construct from.
     */
    public Array(RawArray rawArray, ArrayTraits arrayTraits, ArrayType arrayType, OffsetChecker offsetChecker)
    {
<span class="fc" id="L44">        this(rawArray, arrayTraits, arrayType, offsetChecker, null);</span>
<span class="fc" id="L45">    }</span>

    /**
     * Constructor.
     *
     * @param rawArray          Raw array to construct from.
     * @param arrayTraits       Array traits to construct from.
     * @param arrayType         Array type to construct from.
     * @param offsetChecker     Offset checker to construct from.
     * @param offsetInitializer Offset initializer to construct from.
     */
    public Array(RawArray rawArray, ArrayTraits arrayTraits, ArrayType arrayType, OffsetChecker offsetChecker,
            OffsetInitializer offsetInitializer)
<span class="fc" id="L58">    {</span>
<span class="fc" id="L59">        this.rawArray = rawArray;</span>
<span class="fc" id="L60">        this.arrayTraits = arrayTraits;</span>
<span class="fc" id="L61">        this.packedArrayTraits = arrayTraits.getPackedArrayTraits();</span>
<span class="fc" id="L62">        this.arrayType = arrayType;</span>
<span class="fc" id="L63">        this.offsetChecker = offsetChecker;</span>
<span class="fc" id="L64">        this.offsetInitializer = offsetInitializer;</span>
<span class="fc" id="L65">    }</span>

    @Override
    public boolean equals(java.lang.Object obj)
    {
<span class="fc bfc" id="L70" title="All 2 branches covered.">        return (obj instanceof Array) ? rawArray.equals(((Array)obj).rawArray) : false;</span>
    }

    @Override
    public int hashCode()
    {
<span class="fc" id="L76">        return rawArray.hashCode();</span>
    }

    /**
     * Gets the underlying raw array.
     *
     * @param &lt;T&gt; Java array type to be returned.
     *
     * @return Underlying raw array.
     */
    public &lt;T&gt; T getRawArray()
    {
<span class="fc" id="L88">        return rawArray.getRawArray();</span>
    }

    /**
     * Gets the underlying raw array size.
     *
     * @return The number of elements stored in the underlying raw array.
     */
    public int size()
    {
<span class="fc" id="L98">        return rawArray.size();</span>
    }

    /**
     * Gets the bit size of the array if it is stored in the bit stream.
     *
     * @param bitPosition Current bit position in the bit stream.
     *
     * @return Bit size of the array if it is stored in the bit stream.
     */
    public int bitSizeOf(long bitPosition)
    {
<span class="fc" id="L110">        long endBitPosition = bitPosition;</span>
<span class="fc" id="L111">        final int size = rawArray.size();</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">        if (arrayType == ArrayType.AUTO)</span>
<span class="fc" id="L113">            endBitPosition += BitSizeOfCalculator.getBitSizeOfVarSize(size);</span>

<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (size &gt; 0)</span>
        {
<span class="fc bfc" id="L117" title="All 2 branches covered.">            if (arrayTraits.isBitSizeOfConstant())</span>
            {
<span class="fc" id="L119">                final int elementSize = arrayTraits.bitSizeOf(endBitPosition, ArrayElement.Dummy);</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">                if (offsetInitializer == null)</span>
                {
<span class="fc" id="L122">                    endBitPosition += size * elementSize;</span>
                }
                else
                {
<span class="fc" id="L126">                    endBitPosition = BitPositionUtil.alignTo(Byte.SIZE, endBitPosition);</span>
<span class="fc" id="L127">                    endBitPosition += elementSize + (size - 1) * BitPositionUtil.alignTo(Byte.SIZE, elementSize);</span>
                }
<span class="fc" id="L129">            }</span>
            else
            {
<span class="fc bfc" id="L132" title="All 2 branches covered.">                for (int index = 0; index &lt; size; ++index)</span>
                {
<span class="fc bfc" id="L134" title="All 2 branches covered.">                    if (offsetInitializer != null)</span>
<span class="fc" id="L135">                        endBitPosition = BitPositionUtil.alignTo(Byte.SIZE, endBitPosition);</span>

<span class="fc" id="L137">                    endBitPosition += arrayTraits.bitSizeOf(endBitPosition, rawArray.getElement(index));</span>
                }
            }
        }

<span class="fc" id="L142">        return (int)(endBitPosition - bitPosition);</span>
    }

    /**
     * Returns length of the packed array stored in the bit stream in bits.
     *
     * @param bitPosition Current bit stream position.
     *
     * @return Length of the array stored in the bit stream in bits.
     */
    public int bitSizeOfPacked(long bitPosition)
    {
<span class="fc" id="L154">        checkIfPackable();</span>

<span class="fc" id="L156">        long endBitPosition = bitPosition;</span>
<span class="fc" id="L157">        final int size = rawArray.size();</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (arrayType == ArrayType.AUTO)</span>
<span class="fc" id="L159">            endBitPosition += BitSizeOfCalculator.getBitSizeOfVarSize(size);</span>

<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (size &gt; 0)</span>
        {
<span class="fc" id="L163">            final PackingContext context = packedArrayTraits.createContext();</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">            for (int index = 0; index &lt; size; ++index)</span>
<span class="fc" id="L165">                packedArrayTraits.initContext(context, rawArray.getElement(index));</span>

<span class="fc bfc" id="L167" title="All 2 branches covered.">            for (int index = 0; index &lt; size; ++index)</span>
            {
<span class="fc bfc" id="L169" title="All 2 branches covered.">                if (offsetInitializer != null)</span>
<span class="fc" id="L170">                    endBitPosition = BitPositionUtil.alignTo(Byte.SIZE, endBitPosition);</span>

<span class="fc" id="L172">                endBitPosition += packedArrayTraits.bitSizeOf(</span>
<span class="fc" id="L173">                        context, endBitPosition, rawArray.getElement(index));</span>
            }
        }

<span class="fc" id="L177">        return (int)(endBitPosition - bitPosition);</span>
    }

    /**
     * Initializes indexed offsets for the array.
     *
     * @param bitPosition Current bit position in the bit stream.
     *
     * @return Updated bit stream position which points to the first bit after the array.
     */
    public long initializeOffsets(long bitPosition)
    {
<span class="fc" id="L189">        long endBitPosition = bitPosition;</span>
<span class="fc" id="L190">        final int size = rawArray.size();</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">        if (arrayType == ArrayType.AUTO)</span>
<span class="fc" id="L192">            endBitPosition += BitSizeOfCalculator.getBitSizeOfVarSize(size);</span>

<span class="fc bfc" id="L194" title="All 2 branches covered.">        for (int index = 0; index &lt; size; ++index)</span>
        {
<span class="fc bfc" id="L196" title="All 2 branches covered.">            if (offsetInitializer != null)</span>
            {
<span class="fc" id="L198">                endBitPosition = BitPositionUtil.alignTo(Byte.SIZE, endBitPosition);</span>
<span class="fc" id="L199">                offsetInitializer.setOffset(index, BitPositionUtil.bitsToBytes(endBitPosition));</span>
            }

<span class="fc" id="L202">            endBitPosition = arrayTraits.initializeOffsets(endBitPosition, rawArray.getElement(index));</span>
        }

<span class="fc" id="L205">        return endBitPosition;</span>
    }

    /**
     * Initializes indexed offsets for the packed array.
     *
     * @param bitPosition Current bit stream position.
     *
     * @return Updated bit stream position which points to the first bit after the array.
     */
    public long initializeOffsetsPacked(long bitPosition)
    {
<span class="fc" id="L217">        checkIfPackable();</span>

<span class="fc" id="L219">        long endBitPosition = bitPosition;</span>
<span class="fc" id="L220">        final int size = rawArray.size();</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">        if (arrayType == ArrayType.AUTO)</span>
<span class="fc" id="L222">            endBitPosition += BitSizeOfCalculator.getBitSizeOfVarSize(size);</span>

<span class="fc bfc" id="L224" title="All 2 branches covered.">        if (size &gt; 0)</span>
        {
<span class="fc" id="L226">            final PackingContext context = packedArrayTraits.createContext();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">            for (int index = 0; index &lt; size; ++index)</span>
<span class="fc" id="L228">                packedArrayTraits.initContext(context, rawArray.getElement(index));</span>

<span class="fc bfc" id="L230" title="All 2 branches covered.">            for (int index= 0; index &lt; size; ++index)</span>
            {
<span class="fc bfc" id="L232" title="All 2 branches covered.">                if (offsetInitializer != null)</span>
                {
<span class="fc" id="L234">                    endBitPosition = BitPositionUtil.alignTo(Byte.SIZE, endBitPosition);</span>
<span class="fc" id="L235">                    offsetInitializer.setOffset(index, BitPositionUtil.bitsToBytes(endBitPosition));</span>
                }

<span class="fc" id="L238">                endBitPosition = packedArrayTraits.initializeOffsets(</span>
<span class="fc" id="L239">                        context, endBitPosition, rawArray.getElement(index));</span>
            }
        }

<span class="fc" id="L243">        return endBitPosition;</span>
    }

    /**
     * Reads the array from the bit stream.
     *
     * @param reader Bit stream reader to read from.
     *
     * @throws IOException Failure during bit stream manipulation.
     */
    public void read(BitStreamReader reader) throws IOException
    {
<span class="fc" id="L255">        read(reader, -1);</span>
<span class="fc" id="L256">    }</span>

    /**
     * Reads the array from the bit stream.
     *
     * @param reader Bit stream reader to read from.
     * @param size   Number of elements stored in the array which shall be read.
     *
     * @throws IOException Failure during bit stream manipulation.
     */
    public void read(BitStreamReader reader, int size) throws IOException
    {
<span class="fc" id="L268">        int readSize = size;</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">        if (arrayType == ArrayType.IMPLICIT)</span>
        {
<span class="fc bfc" id="L271" title="All 2 branches covered.">            if (!arrayTraits.isBitSizeOfConstant())</span>
            {
<span class="fc" id="L273">                throw new UnsupportedOperationException(</span>
                        &quot;Array: Implicit array elements must have constant bit size!&quot;);
            }

<span class="fc" id="L277">            final long readerBitPosition = reader.getBitPosition();</span>
<span class="fc" id="L278">            final int elementSize = arrayTraits.bitSizeOf(readerBitPosition, ArrayElement.Dummy);</span>
<span class="fc" id="L279">            final long remainingBits = reader.getBufferBitSize() - readerBitPosition;</span>
<span class="fc" id="L280">            readSize = (int)(remainingBits / elementSize);</span>
<span class="fc" id="L281">        }</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">        else if (arrayType == ArrayType.AUTO)</span>
        {
<span class="fc" id="L284">            readSize = reader.readVarSize();</span>
        }

<span class="fc" id="L287">        rawArray.reset(readSize);</span>

<span class="fc bfc" id="L289" title="All 2 branches covered.">        for (int index = 0; index &lt; readSize; ++index)</span>
        {
<span class="fc bfc" id="L291" title="All 2 branches covered.">            if (offsetChecker != null)</span>
            {
<span class="fc" id="L293">                reader.alignTo(Byte.SIZE);</span>
<span class="fc" id="L294">                offsetChecker.checkOffset(index, reader.getBytePosition());</span>
            }

<span class="fc" id="L297">            final ArrayElement element = arrayTraits.read(reader, index);</span>
<span class="fc" id="L298">            rawArray.setElement(element, index);</span>
        }
<span class="fc" id="L300">    }</span>

    /**
     * Reads packed array from the bit stream.
     *
     * This method has all possible arguments and from generated code is used for aligned object arrays.
     *
     * @param reader Bit stream from which to read.
     *
     * @throws IOException Failure during bit stream manipulation.
     */
    public void readPacked(BitStreamReader reader) throws IOException
    {
<span class="fc" id="L313">        readPacked(reader, -1);</span>
<span class="fc" id="L314">    }</span>

    /**
     * Reads packed array from the bit stream.
     *
     * This method has all possible arguments and from generated code is used for aligned object arrays.
     *
     * @param reader Bit stream from which to read.
     * @param size Number of elements to read.
     *
     * @throws IOException Failure during bit stream manipulation.
     */
    public void readPacked(BitStreamReader reader, int size) throws IOException
    {
<span class="fc" id="L328">        checkIfPackable();</span>

<span class="fc bfc" id="L330" title="All 2 branches covered.">        final int readSize = (arrayType == ArrayType.AUTO) ? reader.readVarSize() : size;</span>

<span class="fc" id="L332">        rawArray.reset(readSize);</span>

<span class="fc bfc" id="L334" title="All 2 branches covered.">        if (readSize &gt; 0)</span>
        {
<span class="fc" id="L336">            final PackingContext context = packedArrayTraits.createContext();</span>

<span class="fc bfc" id="L338" title="All 2 branches covered.">            for (int index = 0; index &lt; readSize; ++index)</span>
            {
<span class="fc bfc" id="L340" title="All 2 branches covered.">                if (offsetChecker != null)</span>
                {
<span class="fc" id="L342">                    reader.alignTo(Byte.SIZE);</span>
<span class="fc" id="L343">                    offsetChecker.checkOffset(index, reader.getBytePosition());</span>
                }

<span class="fc" id="L346">                final ArrayElement element = packedArrayTraits.read(context, reader, index);</span>
<span class="fc" id="L347">                rawArray.setElement(element, index);</span>
            }
        }
<span class="fc" id="L350">    }</span>

    /**
     * Writes the array element to the bit stream.
     *
     * @param writer Bit stream write to write to.
     *
     * @throws IOException Failure during bit stream manipulation.
     */
    public void write(BitStreamWriter writer) throws IOException
    {
<span class="fc" id="L361">        final int size = rawArray.size();</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">        if (arrayType == ArrayType.AUTO)</span>
<span class="fc" id="L363">            writer.writeVarSize(size);</span>

<span class="fc bfc" id="L365" title="All 2 branches covered.">        for (int index = 0; index &lt; size; ++index)</span>
        {
<span class="fc bfc" id="L367" title="All 2 branches covered.">            if (offsetChecker != null)</span>
            {
<span class="fc" id="L369">                writer.alignTo(Byte.SIZE);</span>
<span class="fc" id="L370">                offsetChecker.checkOffset(index, writer.getBytePosition());</span>
            }

<span class="fc" id="L373">            arrayTraits.write(writer, rawArray.getElement(index));</span>
        }
<span class="fc" id="L375">    }</span>

    /**
     * Writes packed array to the bit stream.
     *
     * @param writer Bit stream where to write.
     *
     * @throws IOException Failure during bit stream manipulation.
     */
    public void writePacked(BitStreamWriter writer) throws IOException
    {
<span class="fc" id="L386">        checkIfPackable();</span>

<span class="fc" id="L388">        final int size = rawArray.size();</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">        if (arrayType == ArrayType.AUTO)</span>
<span class="fc" id="L390">            writer.writeVarSize(size);</span>

<span class="fc bfc" id="L392" title="All 2 branches covered.">        if (size &gt; 0)</span>
        {
<span class="fc" id="L394">            final PackingContext context = packedArrayTraits.createContext();</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">            for (int index = 0; index &lt; size; ++index)</span>
<span class="fc" id="L396">                packedArrayTraits.initContext(context, rawArray.getElement(index));</span>

<span class="fc bfc" id="L398" title="All 2 branches covered.">            for (int index = 0; index &lt; size; ++index)</span>
            {
<span class="fc bfc" id="L400" title="All 2 branches covered.">                if (offsetChecker != null)</span>
                {
<span class="fc" id="L402">                    writer.alignTo(Byte.SIZE);</span>
<span class="fc" id="L403">                    offsetChecker.checkOffset(index, writer.getBytePosition());</span>
                }

<span class="fc" id="L406">                packedArrayTraits.write(context, writer, rawArray.getElement(index));</span>
            }
        }
<span class="fc" id="L409">    }</span>

    private void checkIfPackable()
    {
<span class="fc bfc" id="L413" title="All 2 branches covered.">        if (packedArrayTraits == null)</span>
<span class="fc" id="L414">            throw new UnsupportedOperationException(&quot;Array: The array is not packable!&quot;);</span>

<span class="fc bfc" id="L416" title="All 2 branches covered.">        if (arrayType == ArrayType.IMPLICIT)</span>
<span class="fc" id="L417">            throw new UnsupportedOperationException(&quot;Array: Implicit array cannot be packed!&quot;);</span>
<span class="fc" id="L418">    }</span>

    private final RawArray rawArray;
    private final ArrayTraits arrayTraits;
    private final PackedArrayTraits packedArrayTraits;
    private final ArrayType arrayType;
    private final OffsetChecker offsetChecker;
    private final OffsetInitializer offsetInitializer;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>