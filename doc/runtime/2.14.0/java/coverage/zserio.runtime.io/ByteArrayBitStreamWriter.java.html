<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ByteArrayBitStreamWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Zserio Java Runtime Library</a> &gt; <a href="index.source.html" class="el_package">zserio.runtime.io</a> &gt; <span class="el_source">ByteArrayBitStreamWriter.java</span></div><h1>ByteArrayBitStreamWriter.java</h1><pre class="source lang-java linenums">package zserio.runtime.io;

import java.io.EOFException;
import java.io.IOException;
import java.math.BigInteger;

import zserio.runtime.BitFieldUtil;
import zserio.runtime.BitSizeOfCalculator;
import zserio.runtime.FloatUtil;
import zserio.runtime.VarSizeUtil;
import zserio.runtime.ZserioError;

/**
 * A bit stream writer using byte array.
 */
public final class ByteArrayBitStreamWriter extends ByteArrayBitStreamBase implements BitStreamWriter
{
    /**
     * Constructs a new byte array bit stream writer with default capacity and the default endian byte order.
     */
    public ByteArrayBitStreamWriter()
    {
<span class="fc" id="L23">        this(DEFAULT_INITIAL_CAPACITY);</span>
<span class="fc" id="L24">    }</span>

    /**
     * Constructs a new byte array bit stream writer with the given buffer capacity.
     *
     * @param initialCapacity Underlying byte array capacity in bytes.
     */
    public ByteArrayBitStreamWriter(final int initialCapacity)
<span class="fc" id="L32">    {</span>
<span class="fc bfc" id="L33" title="All 4 branches covered.">        if (initialCapacity &lt; 0 || initialCapacity &gt; MAX_BUFFER_SIZE)</span>
<span class="fc" id="L34">            throw new IllegalArgumentException(&quot;ByteArrayBitStreamWriter: Requested initial capacity &quot; +</span>
                    initialCapacity + &quot; of underlying array is out of bounds [1, &quot; + MAX_BUFFER_SIZE + &quot;].&quot;);

<span class="fc" id="L37">        this.buffer = new byte[initialCapacity];</span>
<span class="fc" id="L38">    }</span>

    @Override
    public void writeSignedBits(final long value, final int numBits) throws IOException
    {
<span class="fc" id="L43">        checkRange(numBits);</span>

<span class="fc bfc" id="L45" title="All 2 branches covered.">        if (numBits != 64)</span>
        {
<span class="fc" id="L47">            final long lowerBound = BitFieldUtil.getBitFieldLowerBound(numBits, true);</span>
<span class="fc" id="L48">            final long upperBound = BitFieldUtil.getBitFieldUpperBound(numBits, true);</span>

<span class="pc bpc" id="L50" title="1 of 4 branches missed.">            if (value &lt; lowerBound || value &gt; upperBound)</span>
<span class="fc" id="L51">                throw new IllegalArgumentException(&quot;ByteArrayBitStreamWriter: Value &quot; + value + &quot; does not &quot;</span>
                        + &quot;fit into &quot; + numBits + &quot; bits.&quot;);
        }
        // else: all values are OK

<span class="fc" id="L56">        writeBitsImpl(value, numBits);</span>
<span class="fc" id="L57">    }</span>

    @Override
    public void writeBits(final long value, final int numBits) throws IOException
    {
        // the MSB must be zero
<span class="fc bfc" id="L63" title="All 4 branches covered.">        if (numBits &lt;= 0 || numBits &gt;= 64)</span>
<span class="fc" id="L64">            throw new IllegalArgumentException(&quot;ByteArrayBitStreamWriter: Number of written bits &quot; + numBits +</span>
                    &quot; is out of range [1, 64].&quot;);

<span class="fc" id="L67">        final long lowerBound = 0;</span>
<span class="fc" id="L68">        final long upperBound = BitFieldUtil.getBitFieldUpperBound(numBits, false);</span>

<span class="fc bfc" id="L70" title="All 4 branches covered.">        if (value &lt; lowerBound || value &gt; upperBound)</span>
<span class="fc" id="L71">            throw new IllegalArgumentException(&quot;ByteArrayBitStreamWriter: Written value &quot; + value +</span>
                    &quot; does not fit into &quot; + numBits + &quot; bits.&quot;);

<span class="fc" id="L74">        writeBitsImpl(value, numBits);</span>
<span class="fc" id="L75">    }</span>

    @Override
    public void writeByte(final byte v) throws IOException
    {
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (bitOffset == 0)</span>
        {
<span class="fc" id="L82">            write(v);</span>
        }
        else
        {
<span class="fc" id="L86">            writeSignedBits(v, 8);</span>
        }
<span class="fc" id="L88">    }</span>

    @Override
    public void writeUnsignedByte(final short value) throws IOException
    {
<span class="fc bfc" id="L93" title="All 2 branches covered.">        if (value &lt; 0)</span>
<span class="fc" id="L94">            throw new IllegalArgumentException(</span>
                    &quot;ByteArrayBitStreamWriter: Can't write unsigned byte. Value &quot; + value + &quot; is negative.&quot;);

<span class="fc" id="L97">        writeBits(value, 8);</span>
<span class="fc" id="L98">    }</span>

    @Override
    public void writeShort(final short v) throws IOException
    {
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (bitOffset == 0)</span>
        {
<span class="fc" id="L105">            final byte b0 = (byte)v;</span>
<span class="fc" id="L106">            final byte b1 = (byte)(v &gt;&gt; 8);</span>

<span class="fc" id="L108">            ensureCapacity(16);</span>

<span class="fc" id="L110">            buffer[bytePosition++] = b1;</span>
<span class="fc" id="L111">            buffer[bytePosition++] = b0;</span>
<span class="fc" id="L112">        }</span>
        else
        {
<span class="fc" id="L115">            writeSignedBits(v, 16);</span>
        }
<span class="fc" id="L117">    }</span>

    @Override
    public void writeUnsignedShort(final int value) throws IOException
    {
<span class="fc bfc" id="L122" title="All 2 branches covered.">        if (value &lt; 0)</span>
<span class="fc" id="L123">            throw new IllegalArgumentException(</span>
                    &quot;ByteArrayBitStreamWriter: Can't write unsigned short. Value &quot; + value + &quot; is negative.&quot;);

<span class="fc" id="L126">        writeBits(value, 16);</span>
<span class="fc" id="L127">    }</span>

    @Override
    public void writeInt(final int v) throws IOException
    {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (bitOffset == 0)</span>
        {
<span class="fc" id="L134">            final byte b0 = (byte)v;</span>
<span class="fc" id="L135">            final byte b1 = (byte)(v &gt;&gt; 8);</span>
<span class="fc" id="L136">            final byte b2 = (byte)(v &gt;&gt; 16);</span>
<span class="fc" id="L137">            final byte b3 = (byte)(v &gt;&gt; 24);</span>

<span class="fc" id="L139">            ensureCapacity(32);</span>

<span class="fc" id="L141">            buffer[bytePosition++] = b3;</span>
<span class="fc" id="L142">            buffer[bytePosition++] = b2;</span>
<span class="fc" id="L143">            buffer[bytePosition++] = b1;</span>
<span class="fc" id="L144">            buffer[bytePosition++] = b0;</span>
<span class="fc" id="L145">        }</span>
        else
        {
<span class="fc" id="L148">            writeSignedBits(v, 32);</span>
        }
<span class="fc" id="L150">    }</span>

    @Override
    public void writeUnsignedInt(final long value) throws IOException
    {
<span class="fc bfc" id="L155" title="All 2 branches covered.">        if (value &lt; 0)</span>
<span class="fc" id="L156">            throw new IllegalArgumentException(&quot;ByteArrayBitStreamWriter: Can't write unsigned integer. &quot;</span>
                    + &quot;Value &quot; + value + &quot; is negative.&quot;);

<span class="fc" id="L159">        writeBits(value, 32);</span>
<span class="fc" id="L160">    }</span>

    @Override
    public void writeLong(final long v) throws IOException
    {
<span class="fc bfc" id="L165" title="All 2 branches covered.">        if (bitOffset == 0)</span>
        {
<span class="fc" id="L167">            final byte b0 = (byte)v;</span>
<span class="fc" id="L168">            final byte b1 = (byte)(v &gt;&gt; 8);</span>
<span class="fc" id="L169">            final byte b2 = (byte)(v &gt;&gt; 16);</span>
<span class="fc" id="L170">            final byte b3 = (byte)(v &gt;&gt; 24);</span>
<span class="fc" id="L171">            final byte b4 = (byte)(v &gt;&gt; 32);</span>
<span class="fc" id="L172">            final byte b5 = (byte)(v &gt;&gt; 40);</span>
<span class="fc" id="L173">            final byte b6 = (byte)(v &gt;&gt; 48);</span>
<span class="fc" id="L174">            final byte b7 = (byte)(v &gt;&gt; 56);</span>

<span class="fc" id="L176">            ensureCapacity(64);</span>

<span class="fc" id="L178">            buffer[bytePosition++] = b7;</span>
<span class="fc" id="L179">            buffer[bytePosition++] = b6;</span>
<span class="fc" id="L180">            buffer[bytePosition++] = b5;</span>
<span class="fc" id="L181">            buffer[bytePosition++] = b4;</span>
<span class="fc" id="L182">            buffer[bytePosition++] = b3;</span>
<span class="fc" id="L183">            buffer[bytePosition++] = b2;</span>
<span class="fc" id="L184">            buffer[bytePosition++] = b1;</span>
<span class="fc" id="L185">            buffer[bytePosition++] = b0;</span>
<span class="fc" id="L186">        }</span>
        else
        {
<span class="fc" id="L189">            writeSignedBits(v, 64);</span>
        }
<span class="fc" id="L191">    }</span>

    @Override
    public void writeBigInteger(final BigInteger value, final int numBits) throws IOException
    {
        // total number of bits including sign bit for negative numbers
<span class="fc bfc" id="L197" title="All 2 branches covered.">        final boolean isNegative = value.signum() &lt; 0;</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">        final int valueBits = value.bitLength() + (isNegative ? +1 : 0);</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        if (valueBits &gt; numBits)</span>
<span class="nc" id="L200">            throw new IllegalArgumentException(&quot;ByteArrayBitStreamWriter: Written value &quot; + value +</span>
                    &quot; does not fit into &quot; + numBits + &quot; bits.&quot;);

<span class="fc bfc" id="L203" title="All 2 branches covered.">        if (valueBits &lt; numBits)</span>
        {
<span class="fc" id="L205">            final int paddingBits = numBits - valueBits;</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">            if (isNegative)</span>
<span class="fc" id="L207">                writeOnes(paddingBits);</span>
            else
<span class="fc" id="L209">                writeZeros(paddingBits);</span>
        }

<span class="fc" id="L212">        final byte[] bytes = value.toByteArray();</span>

        // only write the significant bits
        // (BigInteger.toByteArray() is happy to return a leading padding byte)
<span class="fc" id="L216">        int bitsToWrite = 8 - (8 * bytes.length - valueBits);</span>

<span class="fc bfc" id="L218" title="All 2 branches covered.">        for (byte b : bytes)</span>
        {
<span class="fc bfc" id="L220" title="All 2 branches covered.">            if (bitsToWrite != 0)</span>
<span class="fc" id="L221">                writeBitsImpl(((long)b) &amp; 0xffL, bitsToWrite);</span>

<span class="fc" id="L223">            bitsToWrite = 8;</span>
        }
<span class="fc" id="L225">    }</span>

    @Override
    public void writeFloat16(final float value) throws IOException
    {
<span class="fc" id="L230">        writeShort(FloatUtil.convertFloatToShort(value));</span>
<span class="fc" id="L231">    }</span>

    @Override
    public void writeFloat32(final float value) throws IOException
    {
<span class="fc" id="L236">        writeInt(FloatUtil.convertFloatToInt(value));</span>
<span class="fc" id="L237">    }</span>

    @Override
    public void writeFloat64(final double value) throws IOException
    {
<span class="fc" id="L242">        writeLong(FloatUtil.convertDoubleToLong(value));</span>
<span class="fc" id="L243">    }</span>

    @Override
    public void writeBytes(final byte[] value) throws IOException
    {
<span class="fc" id="L248">        writeVarSize(value.length);</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">        if (bitOffset != 0)</span>
        {
            // we are not aligned to byte
<span class="fc bfc" id="L252" title="All 2 branches covered.">            for (byte b : value)</span>
<span class="fc" id="L253">                writeBitsImpl(b, 8);</span>
        }
        else
        {
            // we are aligned to byte
<span class="fc" id="L258">            write(value);</span>
        }
<span class="fc" id="L260">    }</span>

    @Override
    public void writeString(final String value) throws IOException
    {
<span class="fc" id="L265">        final byte[] bytes = value.getBytes(DEFAULT_CHARSET_NAME);</span>
<span class="fc" id="L266">        writeVarSize(bytes.length);</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        if (bitOffset != 0)</span>
        {
            // we are not aligned to byte
<span class="fc bfc" id="L270" title="All 2 branches covered.">            for (byte b : bytes)</span>
<span class="fc" id="L271">                writeBitsImpl(b, 8);</span>
        }
        else
        {
            // we are aligned to byte
<span class="fc" id="L276">            write(bytes);</span>
        }
<span class="fc" id="L278">    }</span>

    @Override
    public void writeBool(final boolean value) throws IOException
    {
<span class="fc bfc" id="L283" title="All 2 branches covered.">        writeBits(value ? 1 : 0, 1);</span>
<span class="fc" id="L284">    }</span>

    @Override
    public void writeVarInt16(final short value) throws IOException
    {
        try
        {
<span class="fc" id="L291">            writeVarNum(value, true, 2, BitSizeOfCalculator.getBitSizeOfVarInt16(value) / 8);</span>
        }
<span class="fc" id="L293">        catch (ZserioError e)</span>
        {
<span class="fc" id="L295">            throw new IOException(e.getMessage());</span>
<span class="fc" id="L296">        }</span>
<span class="fc" id="L297">    }</span>

    @Override
    public void writeVarUInt16(final short value) throws IOException
    {
        try
        {
<span class="fc" id="L304">            writeVarNum(value, false, 2, BitSizeOfCalculator.getBitSizeOfVarUInt16(value) / 8);</span>
        }
<span class="fc" id="L306">        catch (ZserioError e)</span>
        {
<span class="fc" id="L308">            throw new IOException(e.getMessage());</span>
<span class="fc" id="L309">        }</span>
<span class="fc" id="L310">    }</span>

    @Override
    public void writeVarInt32(final int value) throws IOException
    {
        try
        {
<span class="fc" id="L317">            writeVarNum(value, true, 4, BitSizeOfCalculator.getBitSizeOfVarInt32(value) / 8);</span>
        }
<span class="fc" id="L319">        catch (ZserioError e)</span>
        {
<span class="fc" id="L321">            throw new IOException(e.getMessage());</span>
<span class="fc" id="L322">        }</span>
<span class="fc" id="L323">    }</span>

    @Override
    public void writeVarUInt32(final int value) throws IOException
    {
        try
        {
<span class="fc" id="L330">            writeVarNum(value, false, 4, BitSizeOfCalculator.getBitSizeOfVarUInt32(value) / 8);</span>
        }
<span class="fc" id="L332">        catch (ZserioError e)</span>
        {
<span class="fc" id="L334">            throw new IOException(e.getMessage());</span>
<span class="fc" id="L335">        }</span>
<span class="fc" id="L336">    }</span>

    @Override
    public void writeVarInt64(final long value) throws IOException
    {
        try
        {
<span class="fc" id="L343">            writeVarNum(value, true, 8, BitSizeOfCalculator.getBitSizeOfVarInt64(value) / 8);</span>
        }
<span class="fc" id="L345">        catch (ZserioError e)</span>
        {
<span class="fc" id="L347">            throw new IOException(e.getMessage());</span>
<span class="fc" id="L348">        }</span>
<span class="fc" id="L349">    }</span>

    @Override
    public void writeVarUInt64(final long value) throws IOException
    {
        try
        {
<span class="fc" id="L356">            writeVarNum(value, false, 8, BitSizeOfCalculator.getBitSizeOfVarUInt64(value) / 8);</span>
        }
<span class="fc" id="L358">        catch (ZserioError e)</span>
        {
<span class="fc" id="L360">            throw new IOException(e.getMessage());</span>
<span class="fc" id="L361">        }</span>
<span class="fc" id="L362">    }</span>

    @Override
    public void writeVarInt(final long value) throws IOException
    {
<span class="fc bfc" id="L367" title="All 2 branches covered.">        if (value == Long.MIN_VALUE)</span>
        {
<span class="fc" id="L369">            writeByte(VARINT_MIN_VALUE);</span>
        }
        else
        {
            try
            {
<span class="fc" id="L375">                writeVarNum(value, true, 9, BitSizeOfCalculator.getBitSizeOfVarInt(value) / 8);</span>
            }
<span class="nc" id="L377">            catch (ZserioError e)</span>
            {
<span class="nc" id="L379">                throw new IOException(e.getMessage());</span>
<span class="fc" id="L380">            }</span>
        }
<span class="fc" id="L382">    }</span>

    @Override
    public void writeVarUInt(final BigInteger value) throws IOException
    {
<span class="fc" id="L387">        int numBytes = 0;</span>
        try
        {
            // contains validity check
<span class="fc" id="L391">            numBytes = BitSizeOfCalculator.getBitSizeOfVarUInt(value) / 8;</span>
        }
<span class="fc" id="L393">        catch (ZserioError e)</span>
        {
<span class="fc" id="L395">            throw new IOException(e.getMessage());</span>
<span class="fc" id="L396">        }</span>

<span class="fc bfc" id="L398" title="All 2 branches covered.">        final int extraShift = numBytes == VARUINT_MAX_BYTES ? 1 : 0;</span>
<span class="fc" id="L399">        int shift = (numBytes - 1) * 7;</span>

        // first byte
<span class="fc bfc" id="L402" title="All 2 branches covered.">        writeBool(numBytes &gt; 1); // has next byte</span>
<span class="fc" id="L403">        writeBits(value.shiftRight(shift + extraShift).and(VARUINT_BITMASK).longValue(), 7);</span>

        // middle bytes
<span class="fc bfc" id="L406" title="All 2 branches covered.">        for (int i = numBytes - 1; i &gt; 1; i--)</span>
        {
<span class="fc" id="L408">            shift = (i - 1) * 7;</span>
<span class="fc" id="L409">            writeBool(true); // has next byte</span>
<span class="fc" id="L410">            writeBits(value.shiftRight(shift + extraShift).and(VARUINT_BITMASK).longValue(), 7);</span>
        }

        // last byte
<span class="fc bfc" id="L414" title="All 2 branches covered.">        if (numBytes &gt; 1)</span>
        {
<span class="fc bfc" id="L416" title="All 2 branches covered.">            if (numBytes == VARUINT_MAX_BYTES)</span>
            {
                // last possible byte of varuint doesn't have the &quot;has next byte&quot; bit
<span class="fc" id="L419">                writeBits(value.and(VARUINT_9TH_BITMASK).longValue(), 8);</span>
            }
            else
            {
<span class="fc" id="L423">                writeBool(false); // has next byte</span>
<span class="fc" id="L424">                writeBits(value.and(VARUINT_BITMASK).longValue(), 7);</span>
            }
        }
<span class="fc" id="L427">    }</span>

    @Override
    public void writeVarSize(final int value) throws IOException
    {
        try
        {
<span class="fc" id="L434">            writeVarNum(value, false, 5, BitSizeOfCalculator.getBitSizeOfVarSize(value) / 8);</span>
        }
<span class="fc" id="L436">        catch (ZserioError e)</span>
        {
<span class="fc" id="L438">            throw new IOException(e.getMessage());</span>
<span class="fc" id="L439">        }</span>
<span class="fc" id="L440">    }</span>

    @Override
    public void writeBitBuffer(final BitBuffer bitBuffer) throws IOException
    {
<span class="fc" id="L445">        final long bitSize = bitBuffer.getBitSize();</span>
<span class="fc" id="L446">        writeVarSize(VarSizeUtil.convertBitBufferSizeToInt(bitSize));</span>

<span class="fc" id="L448">        final byte[] writeBuffer = bitBuffer.getBuffer();</span>
<span class="fc" id="L449">        final int numBytesToWrite = (int)(bitSize / 8);</span>
<span class="fc" id="L450">        final byte numRestBits = (byte)(bitSize - (long)numBytesToWrite * 8);</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">        if (bitOffset != 0)</span>
        {
            // we are not aligned to byte
<span class="fc bfc" id="L454" title="All 2 branches covered.">            for (int i = 0; i &lt; numBytesToWrite; ++i)</span>
<span class="fc" id="L455">                writeBitsImpl(writeBuffer[i], 8);</span>
        }
        else
        {
            // we are aligned to byte
<span class="fc" id="L460">            write(writeBuffer, 0, numBytesToWrite);</span>
        }

<span class="pc bpc" id="L463" title="1 of 2 branches missed.">        if (numRestBits &gt; 0)</span>
<span class="fc" id="L464">            writeBitsImpl(writeBuffer[numBytesToWrite] &gt;&gt; (8 - numRestBits), numRestBits);</span>
<span class="fc" id="L465">    }</span>

    @Override
    public void alignTo(final int alignVal) throws IOException
    {
<span class="fc" id="L470">        final long offset = getBitPosition() % alignVal;</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">        if (offset != 0)</span>
        {
<span class="fc" id="L473">            final int skip = (int)(alignVal - offset);</span>
<span class="fc" id="L474">            skipBits(skip);</span>
        }
<span class="fc" id="L476">    }</span>

    @Override
    public void close() throws IOException
    {
        // nothing to do
<span class="fc" id="L482">    }</span>

    /**
     * Returns the underlying buffer content as byte array.
     *
     * @return A byte array containing the buffer values.
     *
     * @throws IOException If stream manipulation failed.
     */
    public byte[] toByteArray() throws IOException
    {
<span class="fc" id="L493">        final long bitPos = getBitPosition();</span>
<span class="fc" id="L494">        flushBits();</span>
<span class="fc" id="L495">        final byte[] dest = new byte[bytePosition];</span>
<span class="fc" id="L496">        System.arraycopy(buffer, 0, dest, 0, dest.length);</span>
<span class="fc" id="L497">        setBitPosition(bitPos);</span>
<span class="fc" id="L498">        return dest;</span>
    }

    private void skipBits(final int bitCnt) throws IOException
    {
<span class="fc" id="L503">        writeBits(0, bitCnt);</span>
<span class="fc" id="L504">    }</span>

    private void write(final int b) throws IOException
    {
<span class="fc" id="L508">        flushBits();</span>
<span class="fc" id="L509">        ensureCapacity(8);</span>
<span class="fc" id="L510">        buffer[bytePosition++] = (byte)b;</span>
<span class="fc" id="L511">    }</span>

    private void write(final byte[] src) throws IOException
    {
<span class="fc" id="L515">        write(src, 0, src.length);</span>
<span class="fc" id="L516">    }</span>

    private void write(final byte[] src, final int offset, final int length) throws IOException
    {
<span class="fc" id="L520">        flushBits();</span>
<span class="fc" id="L521">        ensureCapacity(8 * length);</span>
<span class="fc" id="L522">        System.arraycopy(src, offset, buffer, bytePosition, length);</span>
<span class="fc" id="L523">        this.bytePosition += length;</span>
<span class="fc" id="L524">    }</span>

    /**
     * Writes given number of zero bits to the bit stream.
     *
     * @param count Number of zeros to write.
     *
     * @throws IOException If the bits cannot be written.
     */
    private void writeZeros(int count) throws IOException
    {
<span class="fc bfc" id="L535" title="All 2 branches covered.">        while (count &gt; 0)</span>
        {
            // write in 64 - 1 chunks (maximum allowed by writeBits())
<span class="fc" id="L538">            final int bitsToWrite = Math.min(64 - 1, count);</span>
<span class="fc" id="L539">            writeBits(0, bitsToWrite);</span>
<span class="fc" id="L540">            count -= bitsToWrite;</span>
<span class="fc" id="L541">        }</span>
<span class="fc" id="L542">    }</span>

    /**
     * Writes given number of one bits to the bit stream.
     *
     * @param count Number of ones to write.
     *
     * @throws IOException If the bits cannot be written.
     */
    private void writeOnes(int count) throws IOException
    {
<span class="fc bfc" id="L553" title="All 2 branches covered.">        while (count &gt; 0)</span>
        {
            // write in 64 - 2 chunks to avoid overflow ( 1L &lt;&lt; bitsToWrite must stay positive)
<span class="fc" id="L556">            final int bitsToWrite = Math.min(64 - 2, count);</span>
<span class="fc" id="L557">            final long valueToWrite = (1L &lt;&lt; bitsToWrite) - 1L;</span>
<span class="fc" id="L558">            writeBits(valueToWrite, bitsToWrite);</span>
<span class="fc" id="L559">            count -= bitsToWrite;</span>
<span class="fc" id="L560">        }</span>
<span class="fc" id="L561">    }</span>

    /**
     * If the bit offset is non-zero, forces the remaining bits in the current byte to 0 and advances the stream
     * position by one.
     *
     * @exception IOException If some stream manipulation error occurred.
     */
    private final void flushBits() throws IOException
    {
<span class="fc bfc" id="L571" title="All 2 branches covered.">        if (bitOffset != 0)</span>
        {
<span class="fc" id="L573">            final int offset = bitOffset;</span>
<span class="fc" id="L574">            int partialByte = read();</span>
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">            if (partialByte &lt; 0)</span>
            {
<span class="nc" id="L577">                partialByte = 0;</span>
<span class="nc" id="L578">                bitOffset = 0;</span>
            }
            else
            {
<span class="fc" id="L582">                bytePosition--;</span>
<span class="fc" id="L583">                partialByte &amp;= -1 &lt;&lt; (8 - offset);</span>
            }
<span class="fc" id="L585">            write(partialByte);</span>
        }
<span class="fc" id="L587">    }</span>

    /**
     * Writes a variable value with a given sign and the maximum number of variable bytes.
     *
     * @param value       Variable value to write.
     * @param isSigned    A flag indicating if the value is signed.
     * @param maxVarBytes The maximum number of variable bytes.
     * @param numVarBytes The number of variable bytes.
     *
     * @throws IOException If the bytes cannot be written.
     */
    private void writeVarNum(final long value, final boolean isSigned, final int maxVarBytes,
            final int numVarBytes) throws IOException
    {
<span class="fc bfc" id="L602" title="All 2 branches covered.">        final long absValue = (value &lt; 0 ? -value : value);</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">        final boolean max = numVarBytes == maxVarBytes;</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">        for (int i = 0; i &lt; numVarBytes; i++)</span>
        {
<span class="fc bfc" id="L606" title="All 2 branches covered.">            final boolean hasNextByte = i &lt; numVarBytes - 1;</span>
<span class="fc bfc" id="L607" title="All 4 branches covered.">            final int extra = max &amp;&amp; hasNextByte ? 1 : 0;</span>
<span class="fc" id="L608">            final int shift = (numVarBytes - (i + 1)) * 7 + extra;</span>

<span class="fc" id="L610">            long b = 0;</span>
<span class="fc" id="L611">            int numBits = 8;</span>
<span class="fc bfc" id="L612" title="All 4 branches covered.">            if (isSigned &amp;&amp; i == 0)</span>
            {
<span class="fc bfc" id="L614" title="All 2 branches covered.">                b |= (value &lt; 0 ? 1 : 0) &lt;&lt; --numBits;</span>
            }
<span class="fc bfc" id="L616" title="All 2 branches covered.">            if (hasNextByte)</span>
            {
<span class="fc" id="L618">                b |= 1L &lt;&lt; --numBits;</span>
            }
<span class="fc bfc" id="L620" title="All 2 branches covered.">            else if (!max)</span>
            {
<span class="fc" id="L622">                numBits--;</span>
            }
<span class="fc" id="L624">            b |= (absValue &gt;&gt; shift) &amp; (-1L &gt;&gt;&gt; (64 - numBits));</span>
<span class="fc" id="L625">            writeBits(b, 8);</span>
        }
<span class="fc" id="L627">    }</span>

    /**
     * Writes given number of bits of value to bit stream.
     *
     * @param value   Value to write.
     * @param numBits Number of bits of value to write.
     *
     * @throws IOException If the writing failed.
     */
    private void writeBitsImpl(final long value, final int numBits) throws IOException
    {
<span class="fc" id="L639">        ensureCapacity(numBits);</span>

        /*
         * Write pre-existing bytes if we're not at the head of the buffer.
         */
<span class="fc" id="L644">        int nBits = numBits;</span>
<span class="fc bfc" id="L645" title="All 4 branches covered.">        if (bytePosition &gt; 0 || bitOffset &gt; 0)</span>
        {
<span class="fc" id="L647">            final int initialOffset = bitOffset;</span>
<span class="fc" id="L648">            int partialByte = read();</span>
<span class="fc" id="L649">            bytePosition--;</span>

<span class="fc bfc" id="L651" title="All 2 branches covered.">            if (nBits + initialOffset &lt; 8)</span>
            {
<span class="fc" id="L653">                final int shift = 8 - (initialOffset + nBits);</span>
<span class="fc" id="L654">                final int mask = -1 &gt;&gt;&gt; (32 - nBits);</span>
<span class="fc" id="L655">                partialByte &amp;= ~(mask &lt;&lt; shift);</span>
<span class="fc" id="L656">                partialByte |= ((value &amp; mask) &lt;&lt; shift);</span>
<span class="fc" id="L657">                buffer[bytePosition] = (byte)partialByte;</span>
<span class="fc" id="L658">                bitOffset = initialOffset + nBits;</span>
<span class="fc" id="L659">                nBits = 0;</span>
<span class="fc" id="L660">            }</span>
            else
            {
<span class="fc" id="L663">                final int sliceBits = 8 - initialOffset;</span>
<span class="fc" id="L664">                final int mask = -1 &gt;&gt;&gt; (32 - sliceBits);</span>
<span class="fc" id="L665">                partialByte &amp;= ~mask;</span>
<span class="fc" id="L666">                partialByte |= ((value &gt;&gt; (nBits - sliceBits)) &amp; mask);</span>
<span class="fc" id="L667">                buffer[bytePosition++] = (byte)partialByte;</span>
<span class="fc" id="L668">                nBits -= sliceBits;</span>
            }
        }

        /*
         * Write full bytes.
         */
<span class="fc bfc" id="L675" title="All 2 branches covered.">        if (nBits &gt;= 8)</span>
        {
<span class="fc" id="L677">            final int remaining = nBits &amp; BYTE_MOD_MASK;</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">            for (int numBytes = nBits / 8; numBytes &gt; 0; numBytes--)</span>
            {
<span class="fc" id="L680">                final int shift = (numBytes - 1) * 8 + remaining;</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">                final byte byteVal = (byte)((shift == 0 ? value : value &gt;&gt; shift) &amp; 0xff);</span>
<span class="fc" id="L682">                buffer[bytePosition++] = byteVal;</span>
            }
<span class="fc" id="L684">            nBits = remaining;</span>
        }

        /*
         * Write remaining bits.
         */
<span class="fc bfc" id="L690" title="All 2 branches covered.">        if (nBits != 0)</span>
        {
<span class="fc" id="L692">            int partialByte = read();</span>
<span class="fc" id="L693">            final int shift = 8 - nBits;</span>
<span class="fc" id="L694">            final int mask = -1 &gt;&gt;&gt; (32 - nBits);</span>
<span class="fc" id="L695">            partialByte &amp;= ~(mask &lt;&lt; shift);</span>
<span class="fc" id="L696">            partialByte |= (value &amp; mask) &lt;&lt; shift;</span>
<span class="fc" id="L697">            buffer[--bytePosition] = (byte)partialByte;</span>
<span class="fc" id="L698">            bitOffset = nBits;</span>
        }
<span class="fc" id="L700">    }</span>

    /**
     * Resets the bit offset and returns the next unsigned byte.
     *
     * @return Read next unsigned byte.
     *
     * @throws IOException If the reading failed.
     */
    private int read() throws IOException
    {
<span class="fc" id="L711">        bitOffset = 0;</span>
<span class="fc" id="L712">        return nextUnsignedByte();</span>
    }

    /**
     * Returns the next unsigned byte without resetting the bit offset.
     *
     * @return Read next byte.
     *
     * @throws IOException If the reading failed.
     */
    private int nextUnsignedByte() throws IOException
    {
<span class="fc" id="L724">        return nextByte() &amp; 0xff;</span>
    }

    /**
     * Returns the next byte without resetting the bit offset.
     *
     * @return Read next byte.
     *
     * @throws IOException If the reading failed.
     */
    private byte nextByte() throws IOException
    {
<span class="pc bpc" id="L736" title="1 of 2 branches missed.">        if (bytePosition &gt;= buffer.length)</span>
<span class="nc" id="L737">            throw new EOFException(&quot;ByteArrayBitStreamWriter: Internal error, attemp to read beyond end of &quot;</span>
                    + &quot;the buffer. Byte position is &quot; + bytePosition + &quot;. Buffer length is &quot; + buffer.length +
                    &quot;.&quot;);

<span class="fc" id="L741">        return buffer[bytePosition++];</span>
    }

    /**
     * Increases the capacity of the underlying buffer to ensure that it can hold at least the given number of
     * bytes.
     *
     * @param minCapacity The desired minimum capacity.
     *
     * @throws OutOfMemoryError If the requested size exceeded the VM limit.
     */
    private void growBuffer(final int minCapacity)
    {
<span class="fc" id="L754">        final int oldCapacity = buffer.length;</span>
<span class="fc" id="L755">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">        if (newCapacity - minCapacity &lt; 0)</span>
        {
<span class="fc" id="L758">            newCapacity = minCapacity;</span>
        }
<span class="pc bpc" id="L760" title="1 of 2 branches missed.">        if (newCapacity - MAX_BUFFER_SIZE &gt; 0)</span>
        {
<span class="nc bnc" id="L762" title="All 2 branches missed.">            if (minCapacity &lt; 0)</span>
<span class="nc" id="L763">                throw new OutOfMemoryError(&quot;ByteArrayBitStreamWriter: Reached maximum capacity of underlying &quot;</span>
                        + &quot;buffer (&quot; + MAX_BUFFER_SIZE + &quot; bytes).&quot;);

<span class="nc" id="L766">            newCapacity = MAX_BUFFER_SIZE;</span>
        }

<span class="fc" id="L769">        final byte[] newBuffer = new byte[newCapacity];</span>
<span class="fc" id="L770">        System.arraycopy(buffer, 0, newBuffer, 0, oldCapacity);</span>
<span class="fc" id="L771">        buffer = newBuffer;</span>
<span class="fc" id="L772">    }</span>

    /**
     * Method checks if the given next numBits can be stored in the buffer depending on the current byte
     * position. If the buffer is to small for the numBits the buffer is extended.
     *
     * @param numBits Number of bits as integer value to check.
     */
    private void ensureCapacity(final int numBits)
    {
<span class="fc" id="L782">        final int extraBits = numBits &amp; BYTE_MOD_MASK;</span>
<span class="fc" id="L783">        final int numBytes = (numBits / 8);</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">        final int newPosition = bytePosition + numBytes + (extraBits &gt; 0 ? 1 : 0);</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">        if (newPosition &gt;= buffer.length - 1)</span>
        {
<span class="fc" id="L787">            growBuffer(newPosition + 1);</span>
        }
<span class="fc" id="L789">    }</span>

    /**
     * The underlying byte array.
     */
    private byte[] buffer;

    /**
     * The default initial buffer capacity.
     */
    private static final int DEFAULT_INITIAL_CAPACITY = 8192;

    /**
     * The maximum size to allocate for a buffer. Some VMs reserve an additional header word in the underlying
     * array.
     */
    private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;

    /** Minimum VarInt value is Long.MIN_VALUE but it is encoded as -0. */
    private static final byte VARINT_MIN_VALUE = (byte)0x80;

    /** Maximum number of bytes needed to encode VarUInt. */
    private static final int VARUINT_MAX_BYTES = 9;

    /** Bitmask for value in VarUInt byte (except of the 9th byte). */
<span class="fc" id="L814">    private static final BigInteger VARUINT_BITMASK = BigInteger.valueOf(0x7F);</span>
    /** Bitmask for value in VarUInt's 9th byte. */
<span class="fc" id="L816">    private static final BigInteger VARUINT_9TH_BITMASK = BigInteger.valueOf(0xFF);</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>