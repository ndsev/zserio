<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Array.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Zserio Java Runtime Library</a> &gt; <a href="index.source.html" class="el_package">zserio.runtime.array</a> &gt; <span class="el_source">Array.java</span></div><h1>Array.java</h1><pre class="source lang-java linenums">package zserio.runtime.array;

import java.io.IOException;

import zserio.runtime.BitPositionUtil;
import zserio.runtime.BitSizeOfCalculator;
import zserio.runtime.io.BitStreamReader;
import zserio.runtime.io.BitStreamWriter;

/**
 * Array wrapper which is used for mapping of all zserio arrays.
 *
 * Array wrapper is defined by:
 * - raw array
 * - array traits which define zserio methods for array elements of corresponding Java native types
 * - array type (normal, auto, implicit)
 * - offset initializer to set offsets for indexed offsets arrays
 * - offset checker to check offsets for indexed offsets arrays
 */
public final class Array
{
    /**
     * Constructor.
     *
     * @param rawArray    Raw array to construct from.
     * @param arrayTraits Array traits to construct from.
     * @param arrayType   Array type to construct from.
     */
    public Array(RawArray rawArray, ArrayTraits arrayTraits, ArrayType arrayType)
    {
<span class="fc" id="L31">        this(rawArray, arrayTraits, arrayType, null, null);</span>
<span class="fc" id="L32">    }</span>

    /**
     * Constructor.
     *
     * @param rawArray      Raw array to construct from.
     * @param arrayTraits   Array traits to construct from.
     * @param arrayType     Array type to construct from.
     * @param offsetChecker Offset checker to construct from.
     */
    public Array(RawArray rawArray, ArrayTraits arrayTraits, ArrayType arrayType, OffsetChecker offsetChecker)
    {
<span class="fc" id="L44">        this(rawArray, arrayTraits, arrayType, offsetChecker, null);</span>
<span class="fc" id="L45">    }</span>

    /**
     * Constructor.
     *
     * @param rawArray          Raw array to construct from.
     * @param arrayTraits       Array traits to construct from.
     * @param arrayType         Array type to construct from.
     * @param offsetChecker     Offset checker to construct from.
     * @param offsetInitializer Offset initializer to construct from.
     */
    public Array(RawArray rawArray, ArrayTraits arrayTraits, ArrayType arrayType, OffsetChecker offsetChecker,
            OffsetInitializer offsetInitializer)
<span class="fc" id="L58">    {</span>
<span class="fc" id="L59">        this.rawArray = rawArray;</span>
<span class="fc" id="L60">        this.arrayTraits = arrayTraits;</span>
<span class="fc" id="L61">        this.packedArrayTraits = arrayTraits.getPackedArrayTraits();</span>
<span class="fc" id="L62">        this.arrayType = arrayType;</span>
<span class="fc" id="L63">        this.offsetChecker = offsetChecker;</span>
<span class="fc" id="L64">        this.offsetInitializer = offsetInitializer;</span>
<span class="fc" id="L65">    }</span>

    @Override
    public boolean equals(java.lang.Object obj)
    {
<span class="fc bfc" id="L70" title="All 2 branches covered.">        return (obj instanceof Array) ? rawArray.equals(((Array)obj).rawArray) : false;</span>
    }

    @Override
    public int hashCode()
    {
<span class="fc" id="L76">        return rawArray.hashCode();</span>
    }

    /**
     * Gets the underlying raw array.
     *
     * @param &lt;T&gt; Java array type to be returned.
     *
     * @return Underlying raw array.
     */
    public &lt;T&gt; T getRawArray()
    {
<span class="fc" id="L88">        return rawArray.getRawArray();</span>
    }

    /**
     * Gets the underlying raw array size.
     *
     * @return The number of elements stored in the underlying raw array.
     */
    public int size()
    {
<span class="fc" id="L98">        return rawArray.size();</span>
    }

    /**
     * Gets the bit size of the array if it is stored in the bit stream.
     *
     * @param bitPosition Current bit position in the bit stream.
     *
     * @return Bit size of the array if it is stored in the bit stream.
     */
    public int bitSizeOf(long bitPosition)
    {
<span class="fc" id="L110">        long endBitPosition = bitPosition;</span>
<span class="fc" id="L111">        final int size = rawArray.size();</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">        if (arrayType == ArrayType.AUTO)</span>
<span class="fc" id="L113">            endBitPosition += BitSizeOfCalculator.getBitSizeOfVarSize(size);</span>

<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (size &gt; 0)</span>
        {
<span class="fc bfc" id="L117" title="All 2 branches covered.">            if (arrayTraits.isBitSizeOfConstant())</span>
            {
<span class="fc" id="L119">                final int elementSize = arrayTraits.bitSizeOf(endBitPosition, ArrayElement.Dummy);</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">                if (offsetInitializer == null)</span>
                {
<span class="fc" id="L122">                    endBitPosition += size * elementSize;</span>
                }
                else
                {
<span class="fc" id="L126">                    endBitPosition = BitPositionUtil.alignTo(Byte.SIZE, endBitPosition);</span>
<span class="fc" id="L127">                    endBitPosition +=</span>
<span class="fc" id="L128">                            elementSize + (size - 1) * BitPositionUtil.alignTo(Byte.SIZE, elementSize);</span>
                }
<span class="fc" id="L130">            }</span>
            else
            {
<span class="fc bfc" id="L133" title="All 2 branches covered.">                for (int index = 0; index &lt; size; ++index)</span>
                {
<span class="fc bfc" id="L135" title="All 2 branches covered.">                    if (offsetInitializer != null)</span>
<span class="fc" id="L136">                        endBitPosition = BitPositionUtil.alignTo(Byte.SIZE, endBitPosition);</span>

<span class="fc" id="L138">                    endBitPosition += arrayTraits.bitSizeOf(endBitPosition, rawArray.getElement(index));</span>
                }
            }
        }

<span class="fc" id="L143">        return (int)(endBitPosition - bitPosition);</span>
    }

    /**
     * Returns length of the packed array stored in the bit stream in bits.
     *
     * @param bitPosition Current bit stream position.
     *
     * @return Length of the array stored in the bit stream in bits.
     */
    public int bitSizeOfPacked(long bitPosition)
    {
<span class="fc" id="L155">        checkIfPackable();</span>

<span class="fc" id="L157">        long endBitPosition = bitPosition;</span>
<span class="fc" id="L158">        final int size = rawArray.size();</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">        if (arrayType == ArrayType.AUTO)</span>
<span class="fc" id="L160">            endBitPosition += BitSizeOfCalculator.getBitSizeOfVarSize(size);</span>

<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (size &gt; 0)</span>
        {
<span class="fc" id="L164">            final PackingContext context = packedArrayTraits.createContext();</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">            for (int index = 0; index &lt; size; ++index)</span>
<span class="fc" id="L166">                packedArrayTraits.initContext(context, rawArray.getElement(index));</span>

<span class="fc bfc" id="L168" title="All 2 branches covered.">            for (int index = 0; index &lt; size; ++index)</span>
            {
<span class="fc bfc" id="L170" title="All 2 branches covered.">                if (offsetInitializer != null)</span>
<span class="fc" id="L171">                    endBitPosition = BitPositionUtil.alignTo(Byte.SIZE, endBitPosition);</span>

<span class="fc" id="L173">                endBitPosition +=</span>
<span class="fc" id="L174">                        packedArrayTraits.bitSizeOf(context, endBitPosition, rawArray.getElement(index));</span>
            }
        }

<span class="fc" id="L178">        return (int)(endBitPosition - bitPosition);</span>
    }

    /**
     * Initializes indexed offsets for the array.
     *
     * @param bitPosition Current bit position in the bit stream.
     *
     * @return Updated bit stream position which points to the first bit after the array.
     */
    public long initializeOffsets(long bitPosition)
    {
<span class="fc" id="L190">        long endBitPosition = bitPosition;</span>
<span class="fc" id="L191">        final int size = rawArray.size();</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (arrayType == ArrayType.AUTO)</span>
<span class="fc" id="L193">            endBitPosition += BitSizeOfCalculator.getBitSizeOfVarSize(size);</span>

<span class="fc bfc" id="L195" title="All 2 branches covered.">        for (int index = 0; index &lt; size; ++index)</span>
        {
<span class="fc bfc" id="L197" title="All 2 branches covered.">            if (offsetInitializer != null)</span>
            {
<span class="fc" id="L199">                endBitPosition = BitPositionUtil.alignTo(Byte.SIZE, endBitPosition);</span>
<span class="fc" id="L200">                offsetInitializer.setOffset(index, BitPositionUtil.bitsToBytes(endBitPosition));</span>
            }

<span class="fc" id="L203">            endBitPosition = arrayTraits.initializeOffsets(endBitPosition, rawArray.getElement(index));</span>
        }

<span class="fc" id="L206">        return endBitPosition;</span>
    }

    /**
     * Initializes indexed offsets for the packed array.
     *
     * @param bitPosition Current bit stream position.
     *
     * @return Updated bit stream position which points to the first bit after the array.
     */
    public long initializeOffsetsPacked(long bitPosition)
    {
<span class="fc" id="L218">        checkIfPackable();</span>

<span class="fc" id="L220">        long endBitPosition = bitPosition;</span>
<span class="fc" id="L221">        final int size = rawArray.size();</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">        if (arrayType == ArrayType.AUTO)</span>
<span class="fc" id="L223">            endBitPosition += BitSizeOfCalculator.getBitSizeOfVarSize(size);</span>

<span class="fc bfc" id="L225" title="All 2 branches covered.">        if (size &gt; 0)</span>
        {
<span class="fc" id="L227">            final PackingContext context = packedArrayTraits.createContext();</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">            for (int index = 0; index &lt; size; ++index)</span>
<span class="fc" id="L229">                packedArrayTraits.initContext(context, rawArray.getElement(index));</span>

<span class="fc bfc" id="L231" title="All 2 branches covered.">            for (int index = 0; index &lt; size; ++index)</span>
            {
<span class="fc bfc" id="L233" title="All 2 branches covered.">                if (offsetInitializer != null)</span>
                {
<span class="fc" id="L235">                    endBitPosition = BitPositionUtil.alignTo(Byte.SIZE, endBitPosition);</span>
<span class="fc" id="L236">                    offsetInitializer.setOffset(index, BitPositionUtil.bitsToBytes(endBitPosition));</span>
                }

<span class="fc" id="L239">                endBitPosition = packedArrayTraits.initializeOffsets(</span>
<span class="fc" id="L240">                        context, endBitPosition, rawArray.getElement(index));</span>
            }
        }

<span class="fc" id="L244">        return endBitPosition;</span>
    }

    /**
     * Reads the array from the bit stream.
     *
     * @param reader Bit stream reader to read from.
     *
     * @throws IOException Failure during bit stream manipulation.
     */
    public void read(BitStreamReader reader) throws IOException
    {
<span class="fc" id="L256">        read(reader, -1);</span>
<span class="fc" id="L257">    }</span>

    /**
     * Reads the array from the bit stream.
     *
     * @param reader Bit stream reader to read from.
     * @param size   Number of elements stored in the array which shall be read.
     *
     * @throws IOException Failure during bit stream manipulation.
     */
    public void read(BitStreamReader reader, int size) throws IOException
    {
<span class="fc" id="L269">        int readSize = size;</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (arrayType == ArrayType.IMPLICIT)</span>
        {
<span class="fc bfc" id="L272" title="All 2 branches covered.">            if (!arrayTraits.isBitSizeOfConstant())</span>
            {
<span class="fc" id="L274">                throw new UnsupportedOperationException(</span>
                        &quot;Array: Implicit array elements must have constant bit size!&quot;);
            }

<span class="fc" id="L278">            final long readerBitPosition = reader.getBitPosition();</span>
<span class="fc" id="L279">            final int elementSize = arrayTraits.bitSizeOf(readerBitPosition, ArrayElement.Dummy);</span>
<span class="fc" id="L280">            final long remainingBits = reader.getBufferBitSize() - readerBitPosition;</span>
<span class="fc" id="L281">            readSize = (int)(remainingBits / elementSize);</span>
<span class="fc" id="L282">        }</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">        else if (arrayType == ArrayType.AUTO)</span>
        {
<span class="fc" id="L285">            readSize = reader.readVarSize();</span>
        }

<span class="fc" id="L288">        rawArray.reset(readSize);</span>

<span class="fc bfc" id="L290" title="All 2 branches covered.">        for (int index = 0; index &lt; readSize; ++index)</span>
        {
<span class="fc bfc" id="L292" title="All 2 branches covered.">            if (offsetChecker != null)</span>
            {
<span class="fc" id="L294">                reader.alignTo(Byte.SIZE);</span>
<span class="fc" id="L295">                offsetChecker.checkOffset(index, reader.getBytePosition());</span>
            }

<span class="fc" id="L298">            final ArrayElement element = arrayTraits.read(reader, index);</span>
<span class="fc" id="L299">            rawArray.setElement(element, index);</span>
        }
<span class="fc" id="L301">    }</span>

    /**
     * Reads packed array from the bit stream.
     *
     * This method has all possible arguments and from generated code is used for aligned object arrays.
     *
     * @param reader Bit stream from which to read.
     *
     * @throws IOException Failure during bit stream manipulation.
     */
    public void readPacked(BitStreamReader reader) throws IOException
    {
<span class="fc" id="L314">        readPacked(reader, -1);</span>
<span class="fc" id="L315">    }</span>

    /**
     * Reads packed array from the bit stream.
     *
     * This method has all possible arguments and from generated code is used for aligned object arrays.
     *
     * @param reader Bit stream from which to read.
     * @param size Number of elements to read.
     *
     * @throws IOException Failure during bit stream manipulation.
     */
    public void readPacked(BitStreamReader reader, int size) throws IOException
    {
<span class="fc" id="L329">        checkIfPackable();</span>

<span class="fc bfc" id="L331" title="All 2 branches covered.">        final int readSize = (arrayType == ArrayType.AUTO) ? reader.readVarSize() : size;</span>

<span class="fc" id="L333">        rawArray.reset(readSize);</span>

<span class="fc bfc" id="L335" title="All 2 branches covered.">        if (readSize &gt; 0)</span>
        {
<span class="fc" id="L337">            final PackingContext context = packedArrayTraits.createContext();</span>

<span class="fc bfc" id="L339" title="All 2 branches covered.">            for (int index = 0; index &lt; readSize; ++index)</span>
            {
<span class="fc bfc" id="L341" title="All 2 branches covered.">                if (offsetChecker != null)</span>
                {
<span class="fc" id="L343">                    reader.alignTo(Byte.SIZE);</span>
<span class="fc" id="L344">                    offsetChecker.checkOffset(index, reader.getBytePosition());</span>
                }

<span class="fc" id="L347">                final ArrayElement element = packedArrayTraits.read(context, reader, index);</span>
<span class="fc" id="L348">                rawArray.setElement(element, index);</span>
            }
        }
<span class="fc" id="L351">    }</span>

    /**
     * Writes the array element to the bit stream.
     *
     * @param writer Bit stream write to write to.
     *
     * @throws IOException Failure during bit stream manipulation.
     */
    public void write(BitStreamWriter writer) throws IOException
    {
<span class="fc" id="L362">        final int size = rawArray.size();</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">        if (arrayType == ArrayType.AUTO)</span>
<span class="fc" id="L364">            writer.writeVarSize(size);</span>

<span class="fc bfc" id="L366" title="All 2 branches covered.">        for (int index = 0; index &lt; size; ++index)</span>
        {
<span class="fc bfc" id="L368" title="All 2 branches covered.">            if (offsetChecker != null)</span>
            {
<span class="fc" id="L370">                writer.alignTo(Byte.SIZE);</span>
<span class="fc" id="L371">                offsetChecker.checkOffset(index, writer.getBytePosition());</span>
            }

<span class="fc" id="L374">            arrayTraits.write(writer, rawArray.getElement(index));</span>
        }
<span class="fc" id="L376">    }</span>

    /**
     * Writes packed array to the bit stream.
     *
     * @param writer Bit stream where to write.
     *
     * @throws IOException Failure during bit stream manipulation.
     */
    public void writePacked(BitStreamWriter writer) throws IOException
    {
<span class="fc" id="L387">        checkIfPackable();</span>

<span class="fc" id="L389">        final int size = rawArray.size();</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">        if (arrayType == ArrayType.AUTO)</span>
<span class="fc" id="L391">            writer.writeVarSize(size);</span>

<span class="fc bfc" id="L393" title="All 2 branches covered.">        if (size &gt; 0)</span>
        {
<span class="fc" id="L395">            final PackingContext context = packedArrayTraits.createContext();</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">            for (int index = 0; index &lt; size; ++index)</span>
<span class="fc" id="L397">                packedArrayTraits.initContext(context, rawArray.getElement(index));</span>

<span class="fc bfc" id="L399" title="All 2 branches covered.">            for (int index = 0; index &lt; size; ++index)</span>
            {
<span class="fc bfc" id="L401" title="All 2 branches covered.">                if (offsetChecker != null)</span>
                {
<span class="fc" id="L403">                    writer.alignTo(Byte.SIZE);</span>
<span class="fc" id="L404">                    offsetChecker.checkOffset(index, writer.getBytePosition());</span>
                }

<span class="fc" id="L407">                packedArrayTraits.write(context, writer, rawArray.getElement(index));</span>
            }
        }
<span class="fc" id="L410">    }</span>

    private void checkIfPackable()
    {
<span class="fc bfc" id="L414" title="All 2 branches covered.">        if (packedArrayTraits == null)</span>
<span class="fc" id="L415">            throw new UnsupportedOperationException(&quot;Array: The array is not packable!&quot;);</span>

<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (arrayType == ArrayType.IMPLICIT)</span>
<span class="fc" id="L418">            throw new UnsupportedOperationException(&quot;Array: Implicit array cannot be packed!&quot;);</span>
<span class="fc" id="L419">    }</span>

    private final RawArray rawArray;
    private final ArrayTraits arrayTraits;
    private final PackedArrayTraits packedArrayTraits;
    private final ArrayType arrayType;
    private final OffsetChecker offsetChecker;
    private final OffsetInitializer offsetInitializer;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>